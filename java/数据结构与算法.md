#    一、数据结构和算法概述

## 数据结构和算法的关系

数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以
编写出更加漂亮,更加有效率的代码。

要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.程序 = 数据结构 + 算法

数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。

## 线性结构和非线性结构

数据结构包括线性结构和非线性结构

### 线性结构

线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系

线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序
表，顺序表中的存储元素是连续的

链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地
址信息

线性结构常见的有：数组、队列、链表和栈

### 非线性结构

非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 二、稀疏数组和队列

## 稀疏 sparsearray 数组

编写的五子棋程序中，有存盘退出和续上盘的功能。

![image-20220219100908946](images\image-20220219100908946.png)

分析问题:
因为该二维数组的很多值是默认值 0, 因此记录了很多没有意义的数据.->稀疏数组。

### 基本介绍

一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法是:
	1) 记录数组一共有几行几列，有多少个不同的值
	2) 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

稀疏数组举例说明

![image-20220219101008580](images\image-20220219101008580.png)

### 应用实例

使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
把稀疏数组存盘，并且可以从新恢复原来的二维数组数
整体思路分析

![image-20220219101111472](images\image-20220219101111472.png)

### 代码实现

```java
package com.harry.datastructure.array;

import java.io.*;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.List;

public class SparseArray {

     public static void main(String[] args) {

         int[][] baseArray = new int[11][12];
         System.out.println();
         baseArray[2][2] = 1;
         baseArray[3][3] = 2;
         baseArray[3][11] = 2;
         printArray(baseArray);
         int[][] sparseArray = toSparseArray(baseArray);
         printArray(sparseArray);
         printArray(toBaseArray(sparseArray));
     }

    public static void printArray(int inputArray[][]){
        for (int i = 0; i <inputArray.length  ; i++) {
            System.out.println("\t");
            for (int j = 0; j <inputArray[i].length ; j++) {
                System.out.print("\t"+inputArray[i][j]);
            }
        }
    }
    public static int[][] toSparseArray(int baseArray[][]){
        int valueCount = 0;
        for (int i = 0; i <baseArray.length ; i++) {
            for (int j = 0; j <baseArray[i].length ; j++) {
                if (baseArray[i][j] > 0){
                    valueCount++;
                }
            }
        }
        int[][] sparseArray = new int[valueCount+1][3];
        sparseArray[0][0] = baseArray.length;
        sparseArray[0][1] = baseArray[0].length;
        sparseArray[0][2] = valueCount;
        int count = 0;
        for (int i = 0; i < baseArray.length; i++) {
            for (int j = 0; j < baseArray[0].length; j++) {
                if (baseArray[i][j] > 0){
                    count ++;
                    sparseArray[count][0] = i;
                    sparseArray[count][1] = j;
                    sparseArray[count][2] = baseArray[i][j];
                }
            }
        }
        return sparseArray;
    }
    public static int[][] toBaseArray(int sparseArray[][]){
         int [][] newArray = new int[sparseArray[0][0]][sparseArray[0][1]];
        for (int i = 1; i < sparseArray.length; i++) {
            newArray[sparseArray[i][0]][sparseArray[i][1]] = sparseArray[i][2];
        }
         return newArray;
    }
    public static void saveArray(int baseArray[][]){
        try {
            FileOutputStream fileOutputStream = new FileOutputStream(new File("array.data"));
            ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream);
            outputStream.writeObject(baseArray);
            outputStream.flush();
            outputStream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 队列

队列是一个有序列表，可以用数组或是链表来实现。

遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

示意图：(使用数组模拟队列示意）

![image-20220219101307838](images\image-20220219101307838.png)

### 数组模拟队列思路

队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队
列的最大容量。

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标，
front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如图所示:

当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析

​	将尾指针往后移：rear+1 , 当 front == rear 【空】
​	若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据。

​	rear == maxSize - 1[队列满]

```java
package com.harry.datastructure.queue;

import java.util.Scanner;

public class ArrayQueueDemo {
    public static void main(String[] args) {
        //测试一把
        //创建一个队列
        ArrayQueue queue = new ArrayQueue(3);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        // 输出一个菜单
        while (loop){
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g': //取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    }catch (Exception e){
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h': //查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e': //退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
}

// 使用数组模拟队列-编写一个 ArrayQueue 类
class ArrayQueue {
    private int maxSize; // 表示数组的最大容量
    private int front; // 队列头
    private int rear; // 队列尾
    private int[] arr; // 该数据用于存放数据, 模拟队列
    // 创建队列的构造器
    public ArrayQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1; // 指向队列头部，分析出 front 是指向队列头的前一个位置
        rear = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)
    }
    // 判断队列是否满
    public Boolean isFull(){
        return rear == maxSize-1;
    }

    // 判断队列是否为空
    public Boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        // 判断队列是否满
        if(isFull()){
            System.out.println("队列满。不能加入数据");
        }
        rear++; // 让rear 后移
        arr[rear] = n;
    }
    // 获取队列数据。出队列
    public int getQueue(){
        // 判断队列是否空
        if(isEmpty()){
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        front++; // front后移
        return arr[front];
    }
    // 显示队列的所有数据
    public void showQueue(){
        // 遍历
        if(isEmpty()){
            throw new RuntimeException("队列为空，没有数据");
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n", i, arr[i]);
        }
    }
    // 显示队列的头数据，注意不是取出数据
    public int headQueue(){
        // 判断
        if (isEmpty()){
            throw new RuntimeException("队列空的，没有数据");
        }
        return arr[front+1];
    }
}
```

问题分析并优化

 目前数组使用一次就不能用， 没有达到复用的效果
 将这个数组使用算法，改进成一个环形的队列 取模：%

### 数组模拟环形队列

对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可）

分析说明：

​	尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的
时候需要注意 (rear + 1) % maxSize == front 满]

​	fear == front [空]

​	分析示意图:

![image-20220219104940343](images\image-20220219104940343.png)

```java
package com.harry.datastructure.queue;

import java.util.Scanner;

public class CircleArrayQueueDemo {
    public static void main(String[] args) {
        //测试一把
        //创建一个队列
        CircleArray queue = new CircleArray(3);
        char key = ' '; //接收用户输入
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        // 输出一个菜单
        while (loop){
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出程序");
            System.out.println("a(add): 添加数据到队列");
            System.out.println("g(get): 从队列取出数据");
            System.out.println("h(head): 查看队列头的数据");
            key = scanner.next().charAt(0);//接收一个字符
            switch (key){
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输出一个数");
                    int value = scanner.nextInt();
                    queue.addQueue(value);
                    break;
                case 'g': //取出数据
                    try {
                        int res = queue.getQueue();
                        System.out.printf("取出的数据是%d\n", res);
                    }catch (Exception e){
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h': //查看队列头的数据
                    try {
                        int res = queue.headQueue();
                        System.out.printf("队列头的数据是%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e': //退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~");
    }
}

class CircleArray{
    private int maxSize; //表示数组最大容量
    //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素
    //front 的初始值 = 0
    private int front;
    //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.
    //rear 的初始值 = 0
    private int rear; // 队列尾
    private int[] arr; // 该数据用于存放数据, 模拟队列
    public CircleArray(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }
    // 判断队列是否满
    public boolean isFull(){
        return (rear +1) % maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据队列
    public void addQueue(int n){
        // 判断队列是否满
        if (isFull()){
            System.out.println("队列满。不能加入数据~");
            return;
        }
        // 直接将数据加入
        arr[rear] = n;
        // 将rear后移动。这里考虑取模
        rear = (rear + 1) % maxSize;
    }
    // 获取队列的数据。出队列
    public int getQueue(){
        // 判断队列是否空
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // 这里需要分析出 front 是指向队列的第一个元素
        // 1. 先把 front 对应的值保留到一个临时变量
        // 2. 将 front 后移, 考虑取模
        // 3. 将临时保存的变量返回
        int value = arr[front];
        front = (front+1) % maxSize;
        return value;
    }
    public int headQueue(){
        if (isEmpty()) {
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        return arr[front];
    }
    // 显示队列的所有数据
    public void showQueue(){
        // 遍历
        if (isEmpty()) {
            System.out.println("队列空的，没有数据~~");
            return;
        }
        // 思路： 从front开始变量。变量到最后一个怨怒是
        for (int i = front; i < size() ; i++) {
            System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
        }
    }
    // 求出当前队列有效数据的个数
    public int size(){
        // rear = 2
        // front = 1
        // maxSize = 3
        return (rear + maxSize -front) % maxSize;
    }

}
```

# 三、链表

## 链表(Linked List)介绍

链表是有序的列表，但是它在内存中是存储如下

![image-20220220091521244](images\image-20220220091521244.png)

> 结上图:
> 1) 链表是以节点的方式来存储,是链式存储
> 2) 每个节点包含 data 域， next 域：指向下一个节点.
> 3) 如图：发现链表的各个节点不一定是连续存储.
> 4) 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

单链表(带头结点) 逻辑结构示意图如下

![image-20220220091800595](images\image-20220220091800595.png)

### 单链表的应用实例

使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作。

第一种方法在添加英雄时，直接添加到链表的尾部
思路分析示意图:

![image-20220220094445956](images\image-20220220094445956.png)

第二种方式在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)
思路的分析示意图:

![image-20220220094521797](images\image-20220220094521797.png)

修改节点功能
思路(1) 先找到该节点，通过遍历，(2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname

删除节点
思路分析的示意图:

![image-20220220094620259](images\image-20220220094620259.png)

```java
package com.harry.datastructure.linkedlist;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        // 加入
//        singleLinkedList.add(hero1);
//        singleLinkedList.add(hero4);
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
        //加入按照编号的顺序
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
//        singleLinkedList.addByOrder(hero3);
        singleLinkedList.printLink();

        //测试修改节点的代码
        HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");
        singleLinkedList.update(newHeroNode);
        singleLinkedList.printLink();
        singleLinkedList.delete(2);
        singleLinkedList.delete(4);
        singleLinkedList.delete(3);
        singleLinkedList.printLink();
    }
}


class SingleLinkedList{
    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据
    HeroNode headNode = new HeroNode(0, "", "");
    //添加节点到单向链表
    //思路，当不考虑编号顺序时
    //1. 找到当前链表的最后节点
    //2. 将最后这个节点的 next 指向 新的节点
    public void add(HeroNode heroNode) {

        //将最后这个节点的 next 指向 新的节
        HeroNode tempCurrentNode = headNode;
        while (true){
            if (tempCurrentNode.next == null){
                tempCurrentNode.next = heroNode;
                break;
            }
            //如果没有找到最后, 将将 temp 后移
            tempCurrentNode = tempCurrentNode.next;
        }
    }
    public void printLink(){
        if (headNode.next == null){
            System.out.println("链表为空");
        }
        HeroNode tempCurrentNode = headNode.next;
        // 当前节点是最后一个节点
        while (tempCurrentNode != null) {
            System.out.println(tempCurrentNode);
            tempCurrentNode = tempCurrentNode.next;
        }
    }
    public void delete(int no){
        if (headNode.next == null){
            System.out.println("节点为空无法删除");
        }
        HeroNode temp = headNode;
        boolean flag = false;
        while (true){
            if (temp.next == null){
                break;
            }
            if (temp.next.no == no){
                // 找到了要删除的节点
                flag = true;
                break;
            }
            temp = temp.next;
        }
        //判断 flag
        if(flag) { //找到
            //可以删除
            temp.next = temp.next.next;
        }else {
            System.out.printf("要删除的 %d 节点不存在\n", no);
        }
    }
    public void update( HeroNode newHeroNode){
        if (headNode.next == null){
            System.out.println("链表为空");
            return;
        }
        HeroNode temp = headNode.next;
        boolean flag = false;
        while (true){
            if (temp.next == null){
                break;
            }
            if (temp.no == newHeroNode.no){
                // 找到了开始修改
                flag =true;
                break;
            }
            temp = temp.next;
        }
        // 根据 flag 判断是否找到要修改的节点
        if(flag) {
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else { //没有找到
            System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
        }
    }
    public void addByOrder(HeroNode heroNode){
        //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
        //因为单链表，因为我们找的 temp 是位于 添加位置的前一个节点，否则插入不了
        HeroNode temp = headNode;
        boolean flag = false;
        while (true){
            if (temp.next == null){//说明 temp 已经在链表的最后
                break;
            }
            if (heroNode.no == temp.no){
                System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
                flag = true;
                break;
            }
            if (temp.next.no > heroNode.no){
                break;
            }

            temp = temp.next;
        }
        if (!flag){
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    public HeroNode next; //指向下一个节点

    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }


    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                ", next=" + next +
                '}';
    }
}
```

### 单链表面试题(新浪、百度、腾讯)

单链表的常见面试题有如下:

求单链表中有效节点的个数

```java
    /***
      * @return 返回的就是有效节点的个数
    */
    public int getLength(){
        int count = 0;
        if (headNode.next == null){
            return count;
        }
        HeroNode temp = headNode.next;
        while (temp != null){
            count += 1;
            temp = temp.next;
        }
        return count;
    }
```

查找单链表中的倒数第 k 个结点 【新浪面试题】

```java
//查找单链表中的倒数第 k 个结点 【新浪面试题】
    //思路
    //1. 编写一个方法，接收 head 节点，同时接收一个 index
    //2. index 表示是倒数第 index 个节点
    //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength
    //4. 得到 size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到
    //5. 如果找到了，则返回该节点，否则返回 nulll
    public  HeroNode findLastIndexNode(int index){
        if (headNode.next == null){
            System.out.println("空链表");
            return null;
        }
        // 先做一个 index 的校验
        int size = getLength();
        if(index <=0 || index > size) {
            return null;
        }
        HeroNode cur = headNode.next;
        for (int i = 0; i <size -index ; i++) {
            cur = cur.next;
        }
        return cur;
    }
```

### 单链表的反转

#### 思路分析图解

![image-20220220112431751](images\image-20220220112431751.png)

![image-20220220112727143](images\image-20220220112727143.png)

```java
    //将单链表反转
    public  void reverseList() {
        //如果当前链表为空，或者只有一个节点，无需反转，直接返回
        if(headNode.next == null || headNode.next.next == null) {
            return ;
        }
        //定义一个辅助的指针(变量)，帮助我们遍历原来的链表
        HeroNode cur = headNode.next;
        HeroNode next = null;// 指向当前节点[cur]的下一个节点
        HeroNode reverseHead = new HeroNode(0, "", "");
        //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端
        while (cur != null){
            next = cur.next; // 先暂时保存当前节点的下一个节点。后面要用
            cur.next = reverseHead.next; // 及那个cur连接到新的链表上
            reverseHead.next = cur;
            cur = next; // 让cur后移
        }
        // 将head.nex指向 reverseHead.next , 实现单链表的反转
        headNode.next = reverseHead.next;
    }
```

### 从尾到头打印单链表

![image-20220220115428285](images\image-20220220115428285.png)

```java
  public void reversePrint(){
        if (headNode.next == null){
            System.out.println("空列表");
        }
        Stack<HeroNode> nodeStack = new Stack<HeroNode>();
        HeroNode cur = headNode.next;
        while (cur != null){
            nodeStack.push(cur); 
            cur = cur.next;
        }
        while (!nodeStack.isEmpty()){
            System.out.println(nodeStack.pop());//stack 的特点是先进后出
        }
    }
```

### 合并两个有序的单链表，合并之后的链表依然有序

```java
class SingleLinkedList{
    // 先初始化一个头节点, 头节点不要动, 不存放具体的数据
    public HeroNode headNode = null;
    public SingleLinkedList(){
        headNode = new HeroNode(0, "head", "");
    }
    public SingleLinkedList merge(SingleLinkedList linkedList1, SingleLinkedList linkedList2){
        SingleLinkedList newLink = new SingleLinkedList();
        HeroNode newList = new HeroNode(0, "head", "");
        newLink.headNode = newList;
        HeroNode listNodeA = linkedList1.headNode.next;
        HeroNode listNodeB = linkedList2.headNode.next;
        while (listNodeA  != null && listNodeB != null){
            if (listNodeA.no <= listNodeB.no){
                newList.next = listNodeA;
                listNodeA = listNodeA.next;
            }else {
                newList.next = listNodeB;
                listNodeB = listNodeB.next;
            }
            newList = newList.next;
        }
        newList.next = listNodeA != null ? listNodeA:listNodeB;
        return newLink;
    }
}
```

测试

```
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        HeroNode hero5 = new HeroNode(5, "鲁智深", "花和尚");
        HeroNode hero6 = new HeroNode(6, "花荣", "小李广");
        HeroNode hero7 = new HeroNode(7, "李逵", "黑旋风");
        HeroNode hero8 = new HeroNode(8, "武松", "行者");
        HeroNode hero9 = new HeroNode(9, "孙二娘", "母夜叉");
        SingleLinkedList singleLinkedList1 = new SingleLinkedList();
        singleLinkedList1.add(hero1);
        singleLinkedList1.add(hero2);
        singleLinkedList1.add(hero3);
        singleLinkedList1.add(hero7);
        singleLinkedList1.printLink();
        SingleLinkedList singleLinkedList2 = new SingleLinkedList();
        singleLinkedList2.add(hero4);
        singleLinkedList2.add(hero5);
        singleLinkedList2.add(hero6);
        singleLinkedList2.add(hero8);
        singleLinkedList2.add(hero9);
        System.out.println("singleLinkedList2");
        singleLinkedList2.printLink();
        SingleLinkedList mergedList = singleLinkedList1.merge(singleLinkedList1, singleLinkedList2);
        System.out.println("merger");
        mergedList.printLink();
    }
}
```

## 双向链表应用实例

### 双向链表的操作分析和实现

1 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
2 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除
时节点，总是找到 temp,temp 是待删除节点的前一个节点

3 分析了双向链表如何完成遍历，添加，修改和删除的思路

![image-20220221212106505](images\image-20220221212106505.png)

对上图的说明:
分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现

遍历 方和 单链表一样，只是可以向前，也可以向后查找
添加 (默认添加到双向链表的最后）

​	先找到双向链表的最后这个节点，temp.next = newHeroNode，newHeroNode.pre = temp;

修改 思路和 原来的单向链表一样.

删除
	(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
	(2) 直接找到要删除的这个节点，比如 temp
	(3) temp.pre.next = temp.next
	(4) temp.next.pre = temp.pre;

```java
package com.harry.datastructure.linkedlist;

public class DoubleLinkedListDemo {
    public static void main(String[] args) {
        // 测试
        System.out.println("双向链表的测试");
     // 先创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
        // 创建一个双向链表
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
//        doubleLinkedList.add(hero1);
//        doubleLinkedList.add(hero2);
//        doubleLinkedList.add(hero3);
//        doubleLinkedList.add(hero4);

        doubleLinkedList.addByOrder(hero1);
        doubleLinkedList.addByOrder(hero4);
        doubleLinkedList.addByOrder(hero2);
        doubleLinkedList.addByOrder(hero3);
        doubleLinkedList.printLink();

        // 修改
        HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙");
        doubleLinkedList.update(newHeroNode);
        System.out.println("修改后的链表情况");
        doubleLinkedList.printLink();

        doubleLinkedList.delete(4);
        System.out.println("删除4");
        doubleLinkedList.printLink();
    }
}

// 创建一个双向链表的类
class DoubleLinkedList{
    public HeroNode2 headNode = new HeroNode2(0,"","");

    public void add(HeroNode2 heroNode){
        // 当前链表是空的
        HeroNode2 temp = headNode;
        while (true){
            if (temp.next == null){
                temp.next = heroNode;
                heroNode.prev = temp;
                break;
            }
            temp = temp.next;
        }
    }
    public void update(HeroNode2 heroNode){
        HeroNode2 temp = headNode;
        boolean flag = false;
        while (true){
            if (temp == null){
                // 没有找到
                break;
            }
            if (temp.no == heroNode.no){
                flag = true;
                // 要修改的节点指向了当前temp
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        }
    }
    public void  delete(int number){
        if (headNode.next == null){
            System.out.println("链表为空不能删除");
        }
        HeroNode2 temp = headNode;
        while (temp != null){
            System.out.println(temp.no);
            if (temp.no == number){
                // 当前temp 要删除
                if (temp.next == null){
                    System.out.println(temp.prev);
                    temp.prev.next = null;
                }else {
                    temp.next.prev = temp.prev;
                    temp.prev.next = temp.next.next;
                }
                break;
            }
            temp = temp.next;
        }
    }
    public void addByOrder(HeroNode2 heroNode){
        HeroNode2 temp = headNode;
        boolean flag = false;
        while (true){
            // 插到链表尾部
            if (temp.next == null){
                temp.next = heroNode;
                heroNode.prev = temp;
                break;
            }
            // 插到链表最大数的前面
            if (temp.next.no > heroNode.no){
                heroNode.next = temp.next;
                heroNode.prev = temp;
                temp.next.prev = heroNode;
                temp.next = heroNode;
                break;
            }else if (temp.no == heroNode.no){
                System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
                break;
            }
            temp = temp.next;
        }
    }
    public void printLink(){
        if (headNode.next == null){
            System.out.println("链表为空");
        }
        HeroNode2 tempCurrentNode = headNode.next;
        // 当前节点是最后一个节点
        while (tempCurrentNode != null) {
            System.out.println(tempCurrentNode);
            tempCurrentNode = tempCurrentNode.next;
        }
    }

}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode2{
    public int no;
    public String name;
    public String nickname;
    public HeroNode2 next; //指向下一个节点
    public HeroNode2 prev;

    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
//                ", next=" + next +
                ", prev=" + prev +
                '}';
    }
}

```

## 单向环形链表应用场景

### 单向环形链表介绍

![image-20220222200726367](images\image-20220222200726367.png)

### Josephu 问题

​	Josephu 问题为：设编号为 1，2，... n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数
到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由
此产生一个出队编号的序列。

​	提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结
点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直
到最后一个结点从链表中删除算法结束。

约瑟夫问题的示意图

![image-20220222200815949](images\image-20220222200815949.png)

约瑟夫问题-创建环形链表的思路图解

![image-20220222201047280](images\image-20220222201047280.png)

约瑟夫问题-小孩出圈的思路分析图

![image-20220222201112054](images\image-20220222201112054.png)

```java
package com.harry.datastructure.linkedlist;

public class Josepfu {
    public static void main(String[] args) {
        // 测试一把看看构建环形链表，和遍历是否 ok
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(5);// 加入 5 个小孩节点
        circleSingleLinkedList.showBoy();

        circleSingleLinkedList.countBoy(1, 2, 5); // 2->4->1->5->3
    }
}
class CircleSingleLinkedList{
    // 创建第一个first节点，当前没有编号
    Boy first = null;

    public void addBoy(int nums){
        // nums 做一个数据校验
        if (nums < 1) {
            System.out.println("nums 的值不正确");
            return;
        }
        Boy curBoy = null; // 辅助指针，帮助构建环形链
        for (int i = 1; i <= nums ; i++) {
            Boy boy = new Boy(i);
           if (i ==1){
               first = boy;
               curBoy = first;
           }else {
               curBoy.setNext(boy);
               curBoy = curBoy.getNext();
               curBoy.setNext(first);
           }
        }

    }
    // 遍历当前的环形链表
    public void showBoy(){
        // 判断链表是否为空
        if (first == null) {
            System.out.println("没有任何小孩~~");
            return;
        }
        Boy curBoy = first;
        while (true){
            System.out.printf("小孩的编号 %d \n", curBoy.getNo());
            if (curBoy.getNext() == first){
                break;
            }
            curBoy = curBoy.getNext();
        }
    }
    // 根据用户的输入，计算出小孩出圈的顺序
    /**
     *
     * @param startNo
     * 表示从第几个小孩开始数数
     * @param countNum
     * 表示数几下
     * @param nums
     * 表示最初有多少小孩在圈中
     */
    public void countBoy(int startNo, int countNum, int nums){
        // 先对数据进行校验
        if (first == null || startNo < 1 || startNo > nums) {
            System.out.println("参数输入有误， 请重新输入");
            return;
        }
        // 创建辅助指针，帮助完成出圈
        Boy help = first;
        // 说明 helper 指向最后小孩节点， help向移动到队尾
        while (help.getNext() != first) {
            help = help.getNext();
        }
        //小孩报数前，先让 first 和 helper 移动 k -1 次
        for (int i = 0; i < startNo-1 ; i++) {
            first = first.getNext();
            help = help.getNext();
        }
        //当小孩报数时，让 first 和 helper 指针同时 的移动 m - 1 次, 然后出圈
        //这里是一个循环操作，直到圈中只有一个节点

        while (true) {
            if (help == first){
                //说明圈中只有一个节点
                break;
            }
            for (int j = 0; j < countNum - 1; j++) {
                first = first.getNext();
                help = help.getNext();
            }
            //这时 first 指向的节点，就是要出圈的小孩节点
            System.out.printf("小孩%d 出圈\n", first.getNo());
            first = first.getNext();
            help.setNext(first);
        }
        System.out.printf("最后留在圈中的小孩编号%d \n", first.getNo());
    }
}

// 创建一个 Boy 类，表示一个节点
class Boy {
    private int no;// 编号
    private Boy next; // 指向下一个节点,默认 null

    public Boy(int no) {
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public void setNext(Boy next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Boy{" +
                "no=" + no +
                ", next=" + next +
                '}';
    }
}
```

# 四、栈

## 栈的一个实际需求

请输入一个表达式
计算式:[7*2*2-5+1-5+3-3] 点击计算【如下图】

![image-20220222211320939](images\image-20220222211320939.png)

请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 * 2 * 2 -
5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题。-> 栈

## 栈的介绍

> 栈的英文为(stack)
>
> 栈是一个先入后出(FILO-First In Last Out)的有序列表。
>
> 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
>
> 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入元
> 素最先删除，最先放入的元素最后删除
>
> 图解方式说明出栈(pop)和入栈(push)的概念

![image-20220222211457270](images\image-20220222211457270.png)

### 栈的应用场景

> 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
>
> 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
>
> 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
>
> 二叉树的遍历。
>
> 图形的深度优先(depth 一 first)搜索法

## 栈的快速入门

> 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。
>
> 实现思路分析,并画出示意图

![image-20220222211655414](images\image-20220222211655414.png)

```java
package com.harry.datastructure.stack;

import java.util.Scanner;

public class ArrayStackDemo {
    public static void main(String[] args) {
        //测试一下 ArrayStack 是否正确
        //先创建一个 ArrayStack 对象->表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true; //控制是否退出菜单
        Scanner scanner = new Scanner(System.in);
        while (loop){
            System.out.println("show: 表示显示栈");
            System.out.println("exit: 退出程序");
            System.out.println("push: 表示添加数据到栈(入栈)");
            System.out.println("pop: 表示从栈取出数据(出栈)");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key) {
                case "show":
                    stack.list();
                    break;
                case "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据是 %d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出~~~");
    }
}

class ArrayStack {
    private int maxSize;
    private int[] stack; // 数组，数组模拟栈。数据放在数组中
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int num) {
        if (isFull()) {
            System.out.println("数组栈已满，无法入栈");
            return;
        }
        top++;
        stack[top] = num;
    }

    // 出栈
    public int pop() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        for (int i = top; i > -1; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
}
```

## 栈实现综合计算器(中缀表达式)

用栈来实现综合计算器

![image-20220224193216741](images\image-20220224193216741.png)

思路分析(图解）

![image-20220224193240661](images\image-20220224193240661.png)

代价实现[1. 先实现一位数的运算， 2. 扩展到多位数的运算

```java
package com.harry.datastructure.stack;

public class Calculator {
    public static void main(String[] args) {
        // 根据前面老师思路，完成表达式的运算
        String expression = "70*2*2-5000+1-5+3-4"; // 15//如何处理多位数的问题？
        // 创建两个栈，数栈，一个符号栈
        ArrayStack2 numStack = new ArrayStack2(10);
        ArrayStack2 operStack = new ArrayStack2(10);
        // 定义需要的相关变量
        int index = 0;//用于扫描
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' '; //将每次扫描得到 char 保存到 ch
        String keepNum = ""; //用于拼接 多位数
        //开始 while 循环的扫描 expression
        while (true){
            //依次得到 expression 的每一个字符
            ch = expression.substring(index, index+1).charAt(0);
            if (operStack.isOper(ch)){
                if (operStack.isEmpty()){
                    operStack.push(ch);
                }else {
                    //如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中 pop 出两个数,
                    //在从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1, num2, oper);
                        //把运算的结果如数栈
                        numStack.push(res);
                        //然后将当前的操作符入符号栈
                        operStack.push(ch);
                    }else {
                        //如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈
                        operStack.push(ch);
                    }
                }
            }else {
                //如果是数，则直接入数栈
                //分析思路
                //1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
                //2. 在处理数，需要向 expression 的表达式的 index 后再看一位,如果是数就进行扫描，如果是符号才入栈
                //3. 因此我们需要定义一个变量 字符串，用于拼接

                // 处理多位数
                keepNum += ch;
                //如果 ch 已经是 expression 的最后一位，就直接入栈
                if (index == expression.length() - 1) {
                    numStack.push(Integer.parseInt(keepNum));
                }else{
                    //判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
                    //注意是看后一位，不是 index++
                    if (operStack.isOper(expression.substring(index+1, index+2).charAt(0))){
                        // 如果后一位是运算符则入栈， keepNum=”1“ 或者”123“
                        numStack.push(Integer.parseInt(keepNum));
                        //重要的!!!!!!, keepNum 清空
                        keepNum = "";
                    }
                }
            }
            index++;
            if (index >= expression.length()){
                break;
            }
        }
        //当表达式扫描完毕，就顺序的从 数栈和符号栈中 pop 出相应的数和符号，并运行.
        while (!operStack.isEmpty()) {
            // 如果符号栈为空，则计算到最后的结果，数栈中只有一个数字
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1, num2, oper);
            numStack.push(res); // 入栈
        }
        // 将数栈的最后数，pop出就是结果
        int res2 = numStack.pop();
        System.out.printf("表达式 %s = %d", expression, res2);
    }
}

class ArrayStack2 {
    private int maxSize;
    private int[] stack; // 数组，数组模拟栈。数据放在数组中
    private int top = -1;

    public ArrayStack2(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    //栈空
    public boolean isEmpty() {
        return top == -1;
    }

    // 入栈
    public void push(int num) {
        if (isFull()) {
            System.out.println("数组栈已满，无法入栈");
            return;
        }
        top++;
        stack[top] = num;
    }
    //判断是不是一个运算符
    public boolean isOper(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }
    // 出栈
    public int pop() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
    public void list() {
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        for (int i = top; i > -1; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
    // 返回运算符的优先级，优先级是程序员来定，优先级使用数字表示
    // 数字越大，则优先级就越高
    // 单引号是char类型 数字=char
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper =='-'){
            return 0;
        }else {
            return -1; // 假定目前的表达式只有+ -，*，/
        }
    }
    public int cal(int number1, int number2, int oper){
        int res = 0; // res 用于存放计算的结果
        switch (oper){
            case '+':
                res = number1 + number2;
                break;
            case '-':
                res = number2 - number1;
                break;
            case '*':
                res = number1 * number2;
                break;
            case '/':
                res = number2 / number1;
                break;
            default:
                break;
        }
        return res;
    }
    public int peek(){
        if (isEmpty()) {
            //抛出异常
            throw new RuntimeException("栈空，没有数据~");
        }
        return stack[top];
    }
}
```

## 逆波兰计算器

 输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果

 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算

思路分析

> 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
> 1．从左至右扫描，将 3 和 4 压入堆栈；
> 2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
> 3．将 5 入栈；
> 4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
> 5．将 6 入栈；
> 6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果

```java
package com.harry.datastructure.stack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        //(30+4)×5-6 => 30 4 + 5 × 6 - => 164
        // 4 * 5 - 8 + 60 + 8 / 2 => 4 5 * 8 - 60 + 8 2 / +
        //测试
        //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开
        //String suffixExpression = "30 4 + 5 * 6 -";
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76
        //思路
        //1. 先将 "3 4 + 5 × 6 - " => 放到 ArrayList 中
        //2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算
        List<String> list = getListString(suffixExpression);
        System.out.println("rpnList=" + list);
        int res = calculate(list);
        System.out.println("计算的结果是=" + res);
    }
    public static List<String> getListString(String suffixExpression){
        String[] strings = suffixExpression.split(" ");
        return new ArrayList<String>(Arrays.asList(strings).subList(0, strings.length ));
    }
    //完成对逆波兰表达式的运算
    /*
    *   1)从左至右扫描，将 3 和 4 压入堆栈；
        2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
        3)将 5 入栈；
        4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
        5)将 6 入栈；
        6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
    */

    public static int calculate(List<String> ls) {
        // 创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<String>();
        // 遍历ls
        for (String item : ls) {
            // 这里使用正则表达式取出数
            if (item.matches("\\d+")) {
                // 匹配多位数
                stack.push(item);
            } else {
                // pop出两个数，并运算 再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把 res 入栈
                System.out.println(res);
                stack.push("" + res);
            }

        }
        //最后留在 stack 中的数据是运算结果
        return Integer.parseInt(stack.pop());

    }
}

```

## 中缀表达式转换为后缀表达式

大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发
中，我们需要将 中缀表达式转成后缀表达式。

> 具体步骤如下:
> 1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；
> 2) 从左至右扫描中缀表达式；
> 3) 遇到操作数时，将其压 s2；
> 4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级：
>
> ​	1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
> ​	2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1；
> ​	3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较
>
> 5) 遇到括号时：
> 	(1) 如果是左括号“(”，则直接压入 s1
> 	(2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
>
> 6) 重复步骤 2 至 5，直到表达式的最右边
> 7) 将 s1 中剩余的运算符依次弹出并压入 s2
> 8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式



将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下
因此结果为 :"1 2 3 + 4 × + 5 –"

![image-20220224211450140](images\image-20220224211450140.png)

### 代码实现中缀表达式转为后缀表达式

![image-20220224211537043](images\image-20220224211537043.png)

```java
package com.harry.datastructure.stack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Stack;

public class PolandNotation2 {
    public static void main(String[] args) {
        //完成将一个中缀表达式转成后缀表达式的功能
        //说明
        //1. 1+((2+3)×4)-5 => 转成 1 2 3 + 4 × + 5 –
        //2. 因为直接对 str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的 List
        // 即 "1+((2+3)×4)-5" => ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]
        //3. 将得到的中缀表达式对应的 List => 后缀表达式对应的 List
        // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]
        String expression = "100+((2+3)*4)-5";//注意表达式
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("rpnList=" + infixExpressionList);
        List<String> suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);
        System.out.println(suffixExpreesionList);
        System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ?

    }
    //完成对逆波兰表达式的运算
    /*
    *   1)从左至右扫描，将 3 和 4 压入堆栈；
        2)遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈；
        3)将 5 入栈；
        4)接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈；
        5)将 6 入栈；
        6)最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果
    */

    public static int calculate(List<String> ls) {
        // 创建栈，只需要一个栈即可
        Stack<String> stack = new Stack<String>();
        // 遍历ls
        for (String item : ls) {
            // 这里使用正则表达式取出数
            if (item.matches("\\d+")) {
                // 匹配多位数
                stack.push(item);
            } else {
                // pop出两个数，并运算 再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else if (item.equals("/")) {
                    res = num1 / num2;
                } else {
                    throw new RuntimeException("运算符有误");
                }
                //把 res 入栈
                System.out.println(res);
                stack.push("" + res);
            }

        }
        //最后留在 stack 中的数据是运算结果
        return Integer.parseInt(stack.pop());

    }
    //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]
    //方法：将得到的中缀表达式对应的 List => 后缀表达式对应的 List
    public static List<String> parseSuffixExpreesionList(List<String> ls) {
        // 定义两个栈
        Stack<String> s1 = new Stack<>(); // 符号栈
        // 说明：因为s2这个栈在整个转换过程中没有pop操作，而且后面我们还需要逆序输出
        // 因此比较麻烦，这里就不用stack 直接用list
        List<String> s2 = new ArrayList<String>(); // 储存中间结果的 Lists2

        // 遍历ls
        for (String item : ls) {
            //如果是一个数，加入s2
            if (item.matches("\\d+")){
                s2.add(item);
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")){
                    s2.add(s1.pop());
                }
                s1.pop(); //!!! 将(弹出s1栈，消除小括号
            }else {
                // 当item的优先级小于等于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中心的栈顶运算符相比较
                // 问题：我们缺少一个比较优先级高低的方法
                while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item) ) {
                    s2.add(s1.pop());
                }
                //还需要将 item 压入栈
                s1.push(item);
            }
        }
        // 将s1中剩余的运算符依次弹出并加入s2
        while (s1.size() != 0){
            s2.add(s1.pop());
        }
        return s2; //注意因为是存放到 List, 因此按顺序输出就是对应的后缀表达式对应的 List
    }
    // 将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList 中
    public static List<String> getListString(String suffixExpression) {
    //将 suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        return new ArrayList<String>(Arrays.asList(split));
    }
    public static List<String> toInfixExpressionList(String expression){
        ArrayList<String> ls = new ArrayList<>();
        int index = 0;
        String str = ""; // 对多位数的拼接
        char c; // 每遍历到一个字符，就放入到 c
        do {
            //如果 c 是一个非数字，我需要加入到 ls
            if((c=expression.charAt(index)) < 48 || (c=expression.charAt(index)) > 57) {
                ls.add("" + c);
                index++; //i 需要后移
            } else { //如果是一个数，需要考虑多位数
                str = "";
                while (index < expression.length() && (c=expression.charAt(index)) >= 48 && (c=expression.charAt(index)) <= 57){
                    str += c;//拼接
                    index++;
                }
                ls.add(str);
            }
            }while (index < expression.length());
        return ls;
    }
}


// 编写一个类 Operation 可以返回一个运算符 对应的优先级
class Operation {
    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;
    //写一个方法，返回对应的优先级数字
    public static int getValue(String operation) {
        int result = 0;
        switch (operation) {
            case "+":
                result = ADD;
                break;
            case "-":
                result = SUB;break;
            case "*":
                result = MUL;
                break;
            case "/":
                result = DIV;
                break;
            default:
                System.out.println(operation);
                System.out.println("不存在该运算符");
                break;
        }
        return result;
    }
}
```

## 逆波兰计算器完整版

完整版的逆波兰计算器，功能包括
	1) 支持 + - * / ( )
	2) 多位数，支持小数,
	3) 兼容处理, 过滤任何空白字符，包括空格、制表符、换页符

```java
package com.harry.datastructure.stack;

import com.sun.org.apache.bcel.internal.generic.BREAKPOINT;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

public class ReversePolishMultiCalc {
    /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";
    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;
    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;

    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());
    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }
    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }
    /**
    * 判断是不是运算符
    * @param s
    * @return
    */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }
    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }
    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception {
        if (s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if (!isNumber(s.charAt(0) + "")) throw new RuntimeException("data illeagle,start not with a number");
        String each;
        int start = 0;
        for (int i = 0; i <s.length() ; i++) {
            if (isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                // 栈为空，‘（’操作符，或者操作符优先级大于栈顶优先级 && 操作符优先级不是（）的优先级 及是‘）’不能直接入栈）
                // 左括号的情况会入栈
                if (stack.isEmpty() || LEFT.equals(each) ||  ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    // 这里只有符号能加入到data里面
                    while (!stack.isEmpty() && calcLevel(each)<=calcLevel(stack.peek())){
                        if (calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if ((RIGHT.equals(each))){
                    // 当前each是右括号
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if (LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start=i; //前一个运算符的位置
            }
            else if (i == s.length()-1 || isSymbol(s.charAt(i+1)+"")){
                // 如果是字符串的最后以为或者当前的后一位是符号 会从开头截取到最后一个符号之前 或者 从上一个符号截取到下一个符号前肯定是数字
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1, i+1);// start=0相等于是第一位字符，如果当前字符是第一位那么第一位肯定是数字。
                if (isNumber(each)){
                    data.add(each);
                    continue;
                }
                System.out.println(each);
                throw new RuntimeException("data not match number");
            }

        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个 stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));
        System.out.println(data);
        return data;
    }
    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() ==1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i <list.size() ; i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;

    }
    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;
    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8+(2-3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

# 五、递归

## 递归应用场景

看个实际应用场景，迷宫问题(回溯)， 递归(Recursion)

![image-20220227200909767](images\image-20220227200909767.png)

## 递归的概念

简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时
可以让代码变得简洁。

## 递归调用机制

列举两个小案例

1) 打印问题
2) 阶乘问题
3) 使用图解方式说明了递归的调用机制

![image-20220227201126201](images\image-20220227201126201.png)

```java
package com.harry.datastructure.recursion;

public class RecursionTest {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //通过打印问题，回顾递归调用机制
        test(4);
        int res = factorial(5);
        System.out.println("res" + res);
    }
    public static void test(int n){
        if (n > 2) {
            test(n - 1);
        }
        System.out.println("n=" + n);


    }
    public static int factorial(int n){
        if (n == 1){
         return 1;
        }
        int res = factorial(n -1) * n;
        System.out.println("factorial:"+ res);
        return res;
    }
}

```

## 递归能解决什么样的问题

> 1) 各种数学问题如: 8 皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛)
> 2) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
> 3) 将用栈解决的问题-->第归代码比较简洁

## 递归需要遵守的重要规则

> 1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
> 2) 方法的局部变量是独立的，不会相互影响, 比如 n 变量
> 3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
> 4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)
> 5) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

## 递归-迷宫问题

![image-20220227202231077](images\image-20220227202231077.png)

```java
package com.harry.datastructure.recursion;

public class MiGong {
    public static void main(String[] args) {
        // 先创建一个二维数组，模拟迷宫
        // 地图
        int[][] map = new int[8][7];
        // 使用 1 表示墙
        // 上下全部置为 1
        for (int i = 0; i <8 ; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        for (int i = 1; i < 6 ; i++) {
            map[0][i] = 1;
            map[map.length -1][i] = 1;
        }
        // 设置挡板, 1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        // 假设路被堵死
//        map[1][2] = 1;
//        map[2][2] = 1;
        //输出地图
        System.out.println("地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");}
            System.out.println();
        }

        //使用递归回溯给小球找路
//        boolean result = setWay(map, 1, 1);
        boolean result = setWay2(map, 1, 1);
        System.out.println("result:" + result);
        //输出新的地图, 小球走过，并标识过的递归
        System.out.println("小球走过，并标识过的 地图的情况");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }

    //使用递归回溯来给小球找路
    //说明
        //1. map 表示地图
        //2. x,y 表示从地图的哪个位置开始出发 (1,1)
        //3. 如果小球能到 map[6][5] 位置，则说明通路找到.
        //4. 约定： 当 map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通
        //5. 在走迷宫时，需要确定一个策略(方法) 下->右->上->左 , 如果该点走不通，再回
    public static boolean setWay(int[][] map, int x, int y){
        if (map[6][5]==2){
            // 通路已经找到 ok
            return true;
        }else {
            if (map[x][y] == 0){
                // 如果当前这个点还没有走过按照策略 下->右->上->左 走
                map[x][y] = 2; // 假定该点可以走通
                if (setWay(map,x+1, y)){
                    // 往下走
                    return true;
                }else if (setWay(map, x, y+1)){
                    // 往右走
                    return true;
                }else if (setWay(map, x-1, y)){
                    // 往上走
                    return  true;
                }else if (setWay(map, x, y-1)){
                    return true;
                }else {
                    //说明该点是走不通，是死路
                    map[x][y] = 3;
                    return false;
                }
            }else {
                // 如果 map[x][y] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }

    //修改找路的策略，改成 上->右->下->左
    public static boolean setWay2(int[][] map, int x, int y){
        if (map[6][5]==2){
            // 通路已经找到 ok
            return true;
        }else {
            if (map[x][y] == 0){
                map[x][y] = 2; // 假定该点可以走通
                if (setWay2(map,x-1, y)){
                    // 往上走
                    return true;
                }else if (setWay2(map, x, y+1)){
                    // 往右走
                    return true;
                }else if (setWay2(map, x+1, y)){
                     // 下
                    return  true;
                }else if (setWay2(map, x, y-1)){
                    // 左
                    return true;
                }else {
                    //说明该点是走不通，是死路
                    map[x][y] = 3;
                    return false;
                }
            }else {
                // 如果 map[i][j] != 0 , 可能是 1， 2， 3
                return false;
            }
        }
    }

}

```

### 对迷宫问题的讨论

> ```
> 1) 小球得到的路径，和程序员设置的找路策略有关即：找路的上下左右的顺序相关
> 2) 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化
> 3) 测试回溯现象
> 4) 思考: 如何求出最短路径? 思路-》代码实现.
> ```

## 递归-八皇后问题(回溯算法)

皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于
1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、
同一列或同一斜线上，问有多少种摆法(92)

![image-20220227205756244](images\image-20220227205756244.png)

### 八皇后问题算法思路分析

> 1) 第一个皇后先放第一行第一列
> 2) 第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
> 3) 继续第三个皇后，还是第一列、第二列......直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解
> 4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
> 5) 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤
> 6) 示意图:

![image-20220227205915037](images\image-20220227205915037.png)

理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] =
{0 , 4, 7, 5, 2, 6, 1, 3} //对应 arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第 i+1 个皇后，放在第 i+1
行的第 val+1 列

```java
package com.harry.datastructure.recursion;

public class Queen8 {
    // 定义一个max表示共有多少个皇后
    int max = 8;
    // 定义数组array，保存皇后放置位置的结果 比如 arr={0,4,7,5,2,6,1,3}
    int[] array = new int[max];
    static int count = 0;
    static int judgeCount = 0;

    public static void main(String[] args) {
        //测试一把 ， 8 皇后是否正确
        Queen8 queue8 = new Queen8();
        queue8.check(0);
        System.out.printf("一共有%d 解法", count);
        System.out.printf("一共判断冲突的次数%d 次", judgeCount); // 1.5w
    }
    // 编写一个方法，放置n个皇后
    // 特别注意：check是每一次递归时，进入到check中都有for(int i = 0; i < max; i++)，因此会有回溯
    private void check(int n){
        if (n == max){
            // n=8,其实8个皇后就已然放好了
            print();
            return;
        }
        // 依次放入皇后，然后判断是否冲突
        for (int i = 0; i <max ; i++) {
            // 先把当前这个皇后n，放到该行的第一列
            array[n] = i;
            // 判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)){
                // 不冲突
                // 接着放n+1个皇后，即开始递归
                check(n+1);
            }
            //如果冲突，就继续执行array[n] = i, 即将第n个皇后放置本行的后移的一个位置. 如果冲突就退出到上层开始回溯

        }
    }
    // 查看当我们放置第n个皇后，就去检查该皇后是否和前面已经摆放的皇后冲突
    /**
     *
     * @param n 表示第 n 个皇后
     * @return
     */
    private boolean judge(int n){
        // 计算判断次数
        judgeCount++;
        for (int i = 0; i <n ; i++) {
            // 说明
            // 1 array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列
            // 2 Math.abs(n-i) == Math.abs(array[n] -array[i]) 表示判断第n个皇后是否和第i皇后是否在同一个斜线
            // n = 1 放置第 2 列 1 n = 1 array[1] = 1
            // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1
            // 3 判断是否在同一行, 没有必要, n每次都在递增
            if (array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i])){
                // 冲突
                return false;
            }
        }
        return true;
    }
    // 写一个方法，可以将皇后摆放的位置输出
    private void print() {
        count++;
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}

```

# 六、排序算法

排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。

## 排序的分类

内部排序: 指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。

外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。

常见的排序算法分类(见右图):

![image-20220228202010565](images\image-20220228202010565.png)

## 算法的时间复杂度

度量一个程序(算法)执行时间的两种方法

### 事后统计的方法

这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。

### 事前估算的方法

通过分析某个算法的时间复杂度来判断哪个算法更优.

## 时间频度

时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间
就多。一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。[举例说明]

比如计算 1-100 所有数字之和, 我们设计两种算法：

![image-20220228202152513](images\image-20220228202152513.png)

### 忽略常数项

![image-20220228202219767](images\image-20220228202219767.png)

结论:
1) 2n+20 和 2n 随着 n 变大，执行曲线无限接近, 20 可以忽略
2) 3n+10 和 3n 随着 n 变大，执行曲线无限接近, 10 可以忽略

### 忽略低次项

![image-20220228202301861](images\image-20220228202301861.png)

结论:
1) 2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10
2) n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20

### 忽略系数

![image-20220228202349843](images\image-20220228202349843.png)

结论:
1) 随着 n 值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。
2) 而 n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键

## 时间复杂度

​    一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 T(n)表示，若有某个辅
助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。

​    T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同，但时间复杂
度相同，都为 O(n²)。

计算时间复杂度的方法：

​	用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 => T(n)=n²+7n+1
​	修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 => T(n) = n²
​	去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

### 常见的时间复杂度

1) 常数阶 O(1)
2) 对数阶 O(log2n)
3) 线性阶 O(n)
4) 线性对数阶 O(nlog2n)

5) 平方阶 O(n^2)
6) 立方阶 O(n^3)
7) k 次方阶 O(n^k)
8) 指数阶 O(2^n)

常见的时间复杂度对应的图:

![image-20220228203608414](images\image-20220228203608414.png)

说明：
	1) 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜
Ο(2n) ，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
	2) 从图中可见，我们应该尽可能避免使用指数阶的算法

1) 常数阶 O(1)

![image-20220228204200249](images\image-20220228204200249.png)

2) 对数阶 O(log2n)

![image-20220228204231178](images\image-20220228204231178.png)

3) 线性阶 O(n)

![image-20220228204255667](images\image-20220228204255667.png)

4) 线性对数阶 O(nlogN）

![image-20220228204344896](images\image-20220228204344896.png)

5) 平方阶 O(n²)

![image-20220228204411073](images\image-20220228204411073.png)

6) 立方阶 O(n³)、K 次方阶 O(n^k)
说明：参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似

### 平均时间复杂度和最坏时间复杂度

1) 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2) 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的
原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
3) 平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。

![image-20220228204506034](images\image-20220228204506034.png)

## 算法的空间复杂度简介

1)  类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。

2)  空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法, 基数排序就属于这种情况

3)  在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品
(redis, memcache)和算法(基数排序)本质就是用空间换时间

## 冒泡排序

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较
相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

<img src="/images/20160916160748389.gif" style="zoom: 100%" />

优化：
因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在
排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排
序写好后，在进行)

![image-20220228205142888](images\image-20220228205142888.png)

### 冒泡排序应用实例

们将五个无序的数：3, 9, -1, 10, -2 使用冒泡排序法将其排成一个从小
到大的有序数列。

```java
package com.harry.datastructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class BubbleSort {
    public static void main(String[] args) {
//        int arr[] = {3, 9, -1, 10, 20};
//        System.out.println(Arrays.toString(arr));
//        bubbleSort(arr);
//        System.out.println(Arrays.toString(arr));
        //为了容量理解，我们把冒泡排序的演变过程，给大家展示
        //测试一下冒泡排序的速度 O(n^2), 给 80000 个数据，测试
        //创建要给 80000 个的随机的数组
        int[] arr = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);

        bubbleSort(arr);

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);
        //运行结果
//        排序前的时间是=2022-03-01 19:25:30
//        排序前的时间是=2022-03-01 19:25:41
    }

    public static void bubbleSort(int[] array){
        // 冒泡排序 的时间复杂度 O(n^2), 自己写出
        boolean flag = false;
        for (int i = 0; i <array.length - 1 ; i++) {
            for (int j = 0; j < array.length -1 - i; j++) {
                int temp = array[j];
                // 如果前面的数比后面的数大，则交换
                if (array[j] > array[j+1]){
                    array[j] = array[j+1];
                    array[j+1] = temp;
                    flag = true;
                }

            }
            if(!flag){
                // 在一趟排序中，一次交换都没有发生过
                break;
            }else {
                // 重置 flag!!!, 进行下次判断
                flag = false;
            }
        }
    }
}

```

## 选择排序

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到
排序的目的

### 选择排序思想:

​    选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2]交换，...，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，..., 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。

<img src="/images/20160916173802597.gif" style="zoom: 100%" />

对一个数组的选择排序再进行讲解

![image-20220301193258607](images\image-20220301193258607.png)

```java
package com.harry.datastructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class SelectSort {
    public static void main(String[] args) {
        int [] arr = {101, 34, 119, 1, -1, 90, 123};
        selectSort(arr);
        System.out.println(Arrays.toString(arr));
        int[] arr2 = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr2[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);

        selectSort(arr2);

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);
//        排序前的时间是=2022-03-01 19:47:13
//        排序前的时间是=2022-03-01 19:47:17
    }
    public static void selectSort(int[] arr){

        for (int i = 0; i < arr.length; i++) {
            int min = arr[i];
            int minIndex = i;
            for (int j = i+1; j < arr.length; j++) {
                if (min > arr[j]){
                    minIndex = j;
                    min = arr[j];
                }
            }
            if (minIndex != i){
                arr[minIndex] = arr[i];
                arr[i] = min;

            }
        }
    }
}

```

## 插入排序法应用实例

<img src="/images/20160916173802599.gif" style="zoom: 100%" />

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向 前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要 反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：

- <1>.从第一个元素开始，该元素可以认为已经被排序；
- <2>.取出下一个元素，在已经排序的元素序列中从后向前扫描；
- <3>.如果该元素（已排序）大于新元素，将该元素移到下一位置；
- <4>.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- <5>.将新元素插入到该位置后；
- <6>.重复步骤2~5。

```java
package com.harry.datastructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class InsertSort {
    public static void main(String[] args) {
//        int[] arr = {101, 34, 119, 1, -1, 89};
        // 创建要给 80000 个的随机的数组
        int[] arr = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);
        insertSort(arr);
        System.out.println(Arrays.toString(arr));

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);

    }

    public static void insertSort(int[] arr){
        for (int i = 1; i <arr.length; i++) {
            int insertValue = arr[i];
            int insetIndex = i-1;
            while (insetIndex >= 0 && insertValue < arr[insetIndex]){
                arr[insetIndex+1] = arr[insetIndex];
                insetIndex--;
            }
            // 如果insetIndex+1 或者i-1没有变化说明不需要交换否则才需要进行交换
            if (insetIndex != i-1 ){
                // 这里其实就是把最小的数插入到了第一个元素
                arr[insetIndex+1] = insertValue;
            }

        }
    }

}

```

## 希尔排序

### 简单插入排序存在的问题

我们看简单的插入排序可能存在的问题.
数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：
{2,3,4,5,6,6}
{2,3,4,5,5,6}
{2,3,4,4,5,6}
{2,3,3,4,5,6}
{2,2,3,4,5,6}
{1,2,3,4,5,6}

结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响

### 希尔排序法介绍

希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含
的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止

![image-20220303194859353](images\image-20220303194859353.png)

![image-20220303200227333](images\image-20220303200227333.png)

```java

package com.harry.datastructure.sort;

public class ShellSort {

    public static void main(String[] args) {

    }
    // 使用逐步推导的方式来编写希尔排序
    // 希尔排序时， 对有序序列在插入时采用交换法,
    // 思路(算法) ===> 代码
    public static void shellSort(int[] arr){
        for (int gap = arr.length/2;  gap >0 ; gap /=2) {
            for (int i = gap; i < arr.length; i++) {
                // 遍历各组中所有的元素(共gap组。 每组有length/gap个元素) 补偿gap
                for (int j = 0; j >=0 ; j-=gap) {
                    // 如果当前元素大于加上步长后的那个元素，说明交换
                    if (arr[j]>arr[j+gap]){
                        int tmp = arr[j];
                        arr[j] = arr[j+gap];
                        arr[j+gap] = tmp;
                    }
                }
            }
        }
    }
    public static void shellSort2(int[] arr){
        for (int gap = arr.length/2;  gap >0 ; gap /= 2) {
            for (int i = gap; i < arr.length ; i++) {
                int insertValue = arr[i];
                int insetIndex = i;
                if (arr[insetIndex] < arr[insetIndex - gap]){
                    while (insetIndex - gap>= 0 && insertValue < arr[insetIndex-gap]){
                        // 移动
                        arr[insetIndex] = arr[insetIndex-gap];
                        insetIndex-=gap;
                    }
                    // 当退出while就给temp找到插入的位置
                    arr[insetIndex] = insertValue;
                }
            }
        }
    }
}

```

## 快速排序

### 快速排序法介绍

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两
部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排
序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

![image-20220303204256813](images\image-20220303204256813.png)

要求: 对 [-9,78,0,23,-567,70] 进行从小到大的排序，要求使用快速排序法。【测试 8w 和 800w】
说明[验证分析]:

1) 如果取消左右递归，结果是 -9 -567 0 23 78 70

2) 如果取消右递归,结果是 -567 -9 0 23 78 70
3) 如果取消左递归,结果是 -9 -567 0 23 70 78
4) 代码实现



```java
package com.harry.datastructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class QuickSort {
    public static void main(String[] args) {
//        int[] arr = {-9,78,0,23,-567,70, -1,900, 4561};
//
//        System.out.println(Arrays.toString(arr));

        int[] arr = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);
        quickSort(arr,0, arr.length-1);
        System.out.println(Arrays.toString(arr));

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);

    }

    public static void quickSort(int[] arr, int left, int right){

        int l = left; // 左下标
        int r = right; // 又下标

        int pivot = arr[(left + right) /2]; // 中间轴
        int temp = 0; // 临时变量作为交换时使用
        // while循环的目的是让比pivot值小放到左边，比pivot值大放到右边
        while (l < r){
            // 在pivot的左边一直找，找到大于等于pivot值才退出
            while (arr[l] < pivot){
                l++;
            }
            // 在 pivot 的右边一直找,找到小于等于 pivot 值,才退出
            while (arr[r] > pivot){
                r--;
            }
            // 如果l>=r说明pivot左右两边的值已经按照左边全部小于等于pivot的值，右边全部大于等于pivot值
            if(l >=r){
                break;
            }

            // 交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            // 如果交换完成后 发现这个arr[l] == pivot值 相等， r-- 前移
            if (arr[l] == pivot){
                r-=1;
            }
            // 如果交换玩后 发现这个arr[r] == pivot值 相等， l++ 前移
            // 左边移动到右边了 右边移动到了左边
            if (arr[r] == pivot){
                l+=1;
            }
        }
        // 如果 l == r, 必须 l++, r--, 否则为出现栈溢出
        if (l == r) {
            l += 1;
            r -= 1;
        }
        if (left < r){
            // 向左递归
            quickSort(arr,left,r);
        }
        if (right >l){
            quickSort(arr, l, right);
        }
    }
}

```

## 归并排序

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）
策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修
补"在一起，即分而治之)

### 基本思想

![image-20220305095547426](images\image-20220305095547426.png)

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将
[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤

![image-20220305095626753](images\image-20220305095626753.png)

### 归并排序的应用实例

```java
package com.harry.datastructure.sort;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class MergetSort {
    public static void main(String[] args) {
//        int[] arr = { 8, 4, 5, 7, 1, 3, 6, 2 };
//        int[] temp = new int[arr.length]; //归并排序需要一个额外空间

        int[] arr = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);
        int[] temp = new int[arr.length]; //归并排序需要一个额外空间
        mergeSort(arr, 0, arr.length - 1, temp);
//        System.out.println(Arrays.toString(arr));

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);

        System.out.println(Arrays.toString(arr));
    }
    public static void mergeSort(int[] arr, int left, int right, int[] temp){
        if (left < right){
            int mid = (left + right) / 2; // 中间索引
            mergeSort(arr, left, mid, temp); // 向左递归分解
            mergeSort(arr,mid+1, right,temp); // 向右递归分解
            // 合并
            merge(arr, left,mid, right, temp);
        }
    }
    // 合并的方法
    /***
     * @param arr 排序的原始数组
     * @param left 左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边索引
     * @param temp 做中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp){
        int i = left; // 初始化i 左边有序序列的初始化索引
        int j = mid + 1; // 初始化j 右边有序序列的初始索引
        int t = 0; // 指向temp数组的当前索引

        // 先把左右两边(有序)的数据按照规则填充到temp数组， 直到左右两边的有序序列, 有一边处理完毕为止
        while (i<=mid && j<=right){
            // 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素，即将左边的当前元素，填充到temp数组。然后t++ i++
            if (arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t++;
                i++;
            }else {
                // 反之 将右边有序序列的当前元素 填充到temp数组
                temp[t] = arr[j];
                t++;
                j++;
            }



        }
        // 把有剩余数据的一边的数据依次全部填充到temp
        while (i <= mid){
            // 左边的有序序列还有剩余的元素 就全部填充到temp
            temp[t] = arr[i];
            t++;
            i++;
        }

        while (j <= right){
            // 右边的有序序列还有剩余的元素，就全部填充到temp
            temp[t] = arr[j];
            t++;
            j++;
        }

        // 将temp数组的元素拷贝到arr， 注意并不是每次都拷贝所有
        t = 0;
        int tempLeft = left;
        // 第一次合并 tempLeft = 0 , right = 1
        // tempLeft = 2 right = 3
        // tL=0 ri=3
        //最后一次 tempLeft = 0 right = 7
        while (tempLeft <= right){
            arr[tempLeft] = temp[t];
            t++;
            tempLeft++;
        }
    }
}

```

## 基数排序

### 基数排序(桶排序)介绍

> 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort,顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
>
> 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
> 基数排序(Radix Sort)是桶排序的扩展
> 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个
> 位数分别比较

### 基数排序基本思想

将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。
这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤

![image-20220305105836489](images\image-20220305105836489.png)

![image-20220305105855689](images\image-20220305105855689.png)

```java
package com.harry.datastructure.sort;

import java.sql.BatchUpdateException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class RadixSort {
    public static void main(String[] args) {
//        int[] arr = { 53, 3, 542, 748, 14, 214};
//        radixSort(arr);
//        System.out.println(Arrays.toString(arr));


        int[] arr = new int[80000];
        for(int i =0; i < 80000;i++) {
            arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数
        }
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);
        radixSort(arr);
        System.out.println(Arrays.toString(arr));

        Date date2 = new Date();
        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String data2Str = format.format(date2);
        System.out.println("排序前的时间是=" + data2Str);


    }
    public static void radixSort(int[] arr){
        // 1. 得到数组中最大的数的位数
        int max = arr[0]; // 假设第一数就是最大数
        for (int i = 1; i <arr.length ; i++) {
            if (arr[i] > max){
                max = arr[i];
            }
        }

        // 得到最大数是几位数
        int maxLength = (max+"").length();
        // 定义一个二维数组，表示10个桶， 每个桶就是一个一维数组
        /***说明
         * 1. 二维数组包含 10 个一维数组
         * 2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为 arr.length
         * 3. 名明确，基数排序是使用空间换时间的经典算法
         */

        int[][] bucket = new int[10][arr.length];
        //为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数组个数。
        // 可以理解为：bucketElementCounts[0] 记录的就是bucket[0]桶的放入数据个数
        int[] bucketElementCounts = new int[10];

        // 这里我们循环处理代码
        for (int i = 0 , n =1; i <maxLength ; i++,n*=10) {
            //（针对每个元素的对应位进行排序处理），第一次是个位，第二次是十位， 第三次是百位。
            for (int j = 0; j <arr.length ; j++) {
                // 取出每个元素的对应位的值
                int digitOfElement = arr[j] / n % 10;
                // 放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            // 按照这个桶的顺序(一维数组的小标依次取出数据，放入原来数组)
            int index = 0;
            // 遍历每一个桶，并将桶中是数据放入到原数组
            for (int k = 0; k <bucketElementCounts.length ; k++) {
                // 如果桶中有数据，我们才放入到原数组
                if (bucketElementCounts[k] !=0 ){
                    // 循环该桶即第k个桶(即第k个一维数组)，放入
                    for (int l = 0; l <bucketElementCounts[k] ; l++) {
                        // 取出元素放入到arr
                        arr[index] = bucket[k][l];
                        index++;
                    }
                }
                //第1+1轮处理后，需要将每个bucketElementCounts[K] = 0!!
                bucketElementCounts[k] = 0;
            }
        }


    }
}

```

### 基数排序的说明:

> 1) 基数排序是对传统桶排序的扩展，速度很快.
>
> 2) 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成OutOfMemoryError 
>
> 3) 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]
>
> 4) 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: https://code.i-harness.com/zh-CN/q/e98fa9

## 常用排序算法总结和对比

![image-20220306130018948](images\image-20220306130018948.png)

### 相关术语解释：

> 1) 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；
> 2) 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；
> 3) 内排序：所有排序操作都在内存中完成；
> 4) 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
> 5) 时间复杂度： 一个算法执行所耗费的时间。
> 6) 空间复杂度：运行完一个程序所需内存的大小。
> 7) n: 数据规模
> 8) k: “桶”的个数
> 9) In-place: 不占用额外内存
> 10) Out-place: 占用额外内存

# 七、查找算法

在 java 中，我们常用的查找有四种:
1) 顺序(线性)查找
2) 二分查找/折半查找
3) 插值查找
4) 斐波那契查找

## 线性查找算法

```java
package com.harry.datastructure.search;

public class SeqSearch {
    public static void main(String[] args) {
        int arr[] = {1, 9, 11, -1, 34, 89};// 没有顺序的数组
        int index = seqSearch(arr, 9);
        if (index == -1) {
            System.out.println("没有找到到");
        } else {
            System.out.println("找到，下标为=" + index);
        }
    }

    public static int seqSearch(int[] arr, int findValue){
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == findValue){
                return i;
            }
        }
        return -1;
    }
}

```

## 二分查找算

![image-20220306130541009](images\image-20220306130541009.png)

```java
package com.harry.datastructure.search;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class BinarySearch {
    public static void main(String[] args) {
        int arr[] = { 1, 8, 10, 89, 1000, 1000, 1000, 1000, 1000, 1234 };
//        int result = binarySearch(arr, 0, arr.length - 1, 10);
//        System.out.println(result);

        List<Integer> integerList = binarySearch2(arr, 0, arr.length - 2, 1000);
        System.out.println(integerList);

    }
    public static int binarySearch(int[] arr, int left, int right, int findValue){
        if (left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        int midValue = arr[mid];
        if (findValue < midValue){
            // 向左找
            return binarySearch(arr, left,mid-1, findValue);
        }else if (findValue > midValue){
            // 向右找
            return binarySearch(arr, mid+1, right, findValue);
        }else {
            return mid;
        }
    }
    /*
     * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，
     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
     *
     * 思路分析
     * 1. 在找到 mid 索引值，不要马上返回
     * 2. 向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
     * 3. 向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
     * 4. 将 Arraylist 返回
     */
    public static List<Integer> binarySearch2(int[] arr, int left, int right, int findValue){
        if (left > right){
            return new ArrayList<Integer>();
        }
        int mid = (left + right) /2;
        int midValue = arr[mid];
        if (findValue < midValue){
            return binarySearch2(arr,left, mid-1, findValue);
        }else if (findValue > midValue){
            return binarySearch2(arr, mid+1, right, findValue);
        }else {
            List<Integer> resIndexlist = new ArrayList<Integer>();
            // * 思路分析
            // * 1. 在找到 mid 索引值，不要马上返回
            // * 2. 向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            // * 3. 向 mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            // * 4. 将 Arraylist 返回
            //向 mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合 ArrayList
            int temp = mid - 1;
            // 退出
            while (temp >= 0 && arr[temp] == findValue) {
                //  就temp放到resIndexList
                resIndexlist.add(temp);
                temp -= 1;
            }
            // 别忘了把找到的mid也加进入进去
            resIndexlist.add(mid);
            temp = mid +1;
            while (temp < arr.length-1 && arr[temp] == findValue){
                resIndexlist.add(temp);
                temp++;
            }
            return resIndexlist;

        }
    }
}

```

## 插值查找算法

插值查找原理介绍:
插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。

将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right.
key 就是前面我们讲的 findVal

![image-20220307194129569](images\image-20220307194129569.png)

int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/
对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])

![image-20220307194209294](images\image-20220307194209294.png)

```java
package com.harry.datastructure.search;

public class InsertValueSearch {
    public static void main(String[] args) {
        // int [] arr = new int[100];
        // for(int i = 0; i < 100; i++) {
        // arr[i] = i + 1;
        // }
        int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };
        int index = insertValueSearch(arr, 0, arr.length - 1, 1234);
        //int index = binarySearch(arr, 0, arr.length, 1);
        System.out.println("index = " + index);
        //System.out.println(Arrays.toString(arr));
    }
    public static  int insertValueSearch(int[] arr, int left, int right, int findValue){
        if (left > right){
            return -1;
        }
        int mid = left + (right - left) * (findValue - arr[left]) / (arr[right] - arr[left]);

        if (findValue < arr[mid]){
            return insertValueSearch(arr, left, mid-1, findValue);
        }else if (findValue > arr[mid]){
            return insertValueSearch(arr, mid+1 , right, findValue);
        }else {
            return mid;
        }
    }
}

```

### 插值查找注意事项

对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快

关键字分布不均匀的情况下，该方法不一定比折半查找要好

## 斐波那契(黄金分割法)查找算法

### 斐波那契(黄金分割法)查找基本介绍

黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位
数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神
奇的数字，会带来意向不大的效果。

斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值
0.618

### 斐波那契(黄金分割法)原理

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位
于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示

![image-20220307195453856](images\image-20220307195453856.png)

### 对 F(k-1)-1 的理解：

由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：
只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1

类似的，每一子段也可以用相同的方式分割

但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使
得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置），
都赋为 n 位置的值即可。

while(n>fib(k)-1)
	k++；

### 斐波那契查找应用案例

请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求
出下标，如果没有就提示"没有这个数"

```java
package com.harry.datastructure.search;

import java.util.Arrays;

public class FibonacciSearch {
    public static int maxSize = 20;
    public static void main(String[] args) {
        int [] arr = {1,8, 10, 89, 1000, 1234};
        System.out.println("index=" + fibSearch(arr, 89));// 0
    }

    // 因为后面我们mid=low+F(k-1)-1 需要使用斐波那契数列。因此我们需要先获取到一个斐波那契数列
    // 非递归方法得到一个斐波那契数列
    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i-1] + f[i-2];
        }
        return f;
    }

    //编写斐波那契查找算法
    //使用非递归的方式编写算法
    /**
     *
     * @param a 数组
     * @param key 我们需要查找的关键码(值)
     * @return 返回对应的下标，如果没有-1
     */
    public static int fibSearch(int[] a, int key){
        int low = 0;
        int high = a.length - 1;
        int k = 0; // 表示斐波那契分割数值的下标
        int mid = 0; // 存放mid值
        int f[] = fib(); // 获取到斐波那契数列
        // 获取到斐波那契分割数值的下标
        while (high > f[k]-1){
            k++;
        }
        // 因为f[k]值可能大于a的长度，因此我们需要使用Arrays类 构造一个新的数组，并指向temp[]
        // 不足的部分使用0填充
        int[] temp = Arrays.copyOf(a, f[k]);
        //实际上需求使用 a 数组最后的数填充 temp
        //举例:
        //temp = {1,8, 10, 89, 1000, 1234, 0, 0} => {1,8, 10, 89, 1000, 1234, 1234, 1234,}
        for (int i = high +1; i < temp.length; i++) {
            temp[i] = a[high];
        }

        // 使用while来循环处理，找到我们的数key
        while (low <= high){
            // 只要这个条件满足就可以找
            mid = low + f[k-1]-1;
            if (key < temp[mid]){
                // 我们应该继续向数组的前面查找(左边)
                high = mid-1;
                // 说明： 1. 全部元素= 前面的元素 + 后边元素。 2. f[k] = f[k-1] + f[k-2]
                // 因为 前面有f[k-1]个元素。所以可以继续差分 f[k-1] = f[k-2] + f[k-3]
                //即 在 f[k-1] 的前面继续查找 k--
                //即下次循环 mid = f[k-1-1]-1
                k--;
            }else if (key > temp[mid]){
                // 我们应该继续向数组的后面查找(右边)
                low = mid +1;
                //为什么是 k -=2
                //说明
                //1. 全部元素 = 前面的元素 + 后边元素
                //2. f[k] = f[k-1] + f[k-2]
                //3. 因为后面我们有 f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]
                //4. 即在 f[k-2] 的前面进行查找 k -=2
                //5. 即下次循环 mid = f[k - 1 - 2] - 1
                k -= 2;
            }else {
                // 找到
                // 需要确定返回的是哪个下标
                if (mid <= high){
                    return mid;
                }else {
                    return high;
                }
            }
        }
        return -1;
    }
}

```

# 八、哈希表

看一个实际需求，google 公司的一个上机题:有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的 id 时,要求查找到该员工的 所有信息.不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列)

## 哈希表的基本介绍

散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通
过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组
叫做散列表。

![image-20220309201447015](images\image-20220309201447015.png)

![image-20220309201552826](images\image-20220309201552826.png)

```java
package com.harry.datastructure.hash;

import java.util.Scanner;

public class HashTabDemo {
    public static void main(String[] args) {
        //创建哈希表
        HashTab hashTab = new HashTab(7);
        //写一个简单的菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true){
            System.out.println("add: 添加雇员");
            System.out.println("list: 显示雇员");
            System.out.println("find: 查找雇员");
            System.out.println("exit: 退出系统");
            key = scanner.next();
            switch (key){
                case "add":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    Emp emp = new Emp(id, name);
                    hashTab.add(emp);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "find":
                    System.out.println("请输入要查找的id");
                    id = scanner.nextInt();
                    hashTab.findEmpById(id);
                    break;
                case "exit":
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}

class Emp{
    public int id;
    public String name;
    public Emp next;

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

// 创建HashTab管理多条链表
class HashTab{
    private EmpLinkedList[] empLinkedListsArray;
    private int size; // 表示有多少条链表

    public HashTab(int size){
        this.size = size;
        empLinkedListsArray = new EmpLinkedList[size];
        // 初始化每个链表
        for (int i = 0; i <size ; i++) {
            empLinkedListsArray[i] = new EmpLinkedList();
        }
    }

    public void add (Emp emp){
        // 根据员工的id，得到该员工应该添加到哪条链表
        int empLinkedListNO = hashFun(emp.id);
        // 将emp添加到对应的链表中
        empLinkedListsArray[empLinkedListNO].add(emp);
    }

    // 遍历所有链表，遍历hashtab
    public void list(){
        for (int i = 0; i <size ; i++) {
            empLinkedListsArray[i].list(i);
        }
    }

    // 根据输入的id，查找雇员
    public void findEmpById(int id){
        // 使用散列函数确定到哪条链表查找
        int empLinkedListNo = hashFun(id);
        Emp emp = empLinkedListsArray[empLinkedListNo].findEmpById(id);
        if (emp != null){
            System.out.printf("在第%d 条链表中找到 雇员 id = %d\n", (empLinkedListNo  + 1), id);
        }else{
            System.out.println("在哈希表中，没有找到该雇员~");
        }

    }
    public int hashFun(int id){
        return id % size;
    }
}

// 创建EmpLinkedList 表示链表
class EmpLinkedList{
    // 头指针。指向第一个Emp，因此我们这个链表的head是直接指向第一个Emp
    private Emp head; // 默认null

    // 添加雇员到链表
    //1. 假定当添加雇员时，id是自增长，即id的分配总是从小到大，因此我们将雇员直接加入到本链表的最后即可
    public void add(Emp emp){
        // 如果是添加第一个雇员
        if (head == null){
            head = emp;
            return;
        }
        Emp temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        // 退出时直接将emp加入链表
        temp.next = emp;
    }

    // 遍历链表的雇员信息
    public void list(int no){
        if (head == null){
            System.out.println("第 "+(no+1)+" 链表为空");
            return;
        }
        System.out.print("第 "+(no+1)+" 链表的信息为");
        Emp curEmp = head; // 辅助指针
        while (true){
            System.out.printf(" => id=%d name=%s\t", curEmp.id, curEmp.name);
            if (curEmp.next == null){
                break;
            }
            curEmp = curEmp.next;
        }
        System.out.println();
    }
    // 根据id查找雇员
    // 如果查找到就返回Emp 如果没有找到就返回null
    public Emp findEmpById(int d){
        // 判断链表是否为空
        if (head == null){
            System.out.println("链表为空");
            return null;
        }
        Emp curEmp = head;
        while (true){
            if (curEmp.id == d){
                break; // 找到， 这时curEmp就要指向要查找的雇员
            }
            if (curEmp.next == null){
                // 说明遍历当前链表没有找到该雇员
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;
        }
        return curEmp;
    }
}
```

# 九、树结构的基础部分

## 1、二叉树

### 为什么需要树这种数据结构

1）数组存储方式的分析

优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。
缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 [示意图]
画出操作示意图：

![image-20220309204934515](images\image-20220309204934515.png)

2) 链式存储方式的分析

优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，
删除效率也很好)。
缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】

![image-20220309205006566](images\image-20220309205006566.png)

3) 树存储方式的分析

能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也
可以保证数据的插入，删除，修改的速度

![image-20220309205033107](images\image-20220309205033107.png)

### 树示意图

![image-20220309205107883](images\image-20220309205107883.png)

```
树的常用术语(结合示意图理解):
1) 节点
2) 根节点
3) 父节点
4) 子节点
5) 叶子节点 (没有子节点的节点)
6) 节点的权(节点值)
7) 路径(从 root 节点找到该节点的路线)
8) 层
9) 子树
10) 树的高度(最大层数)
11) 森林 :多颗子树构成森林
```

### 二叉树的概念

1) 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
2) 二叉树的子节点分为左节点和右节点
3) 示意图

![image-20220309205158321](images\image-20220309205158321.png)

4) 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。

![image-20220309205216399](images\image-20220309205216399.png)

5) 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二
层的叶子节点在右边连续，我们称为完全二叉树

![image-20220309205247174](images\image-20220309205247174.png)

### 二叉树遍历的说明

使用前序，中序和后序对下面的二叉树进行遍历.

1) 前序遍历: 先输出父节点，再遍历左子树和右子树
2) 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树

3) 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点
4) 小结: 看输出父节点的顺序，就确定是前序，中序还是后序

### 二叉树遍历应用实例(前序,中序,后序)

![image-20220309205337758](images\image-20220309205337758.png)

```java
package com.harry.datastructure.tree;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建需要的结点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
        //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);

        //测试
        System.out.println("前序遍历"); // 1,2,3,5,4
        binaryTree.preOrder();
        //测试
        System.out.println("中序遍历");
        binaryTree.infixOrder(); // 2,1,5,3,4
        //
        System.out.println("后序遍历");
        binaryTree.postOrder(); // 2,5,4,3,1
    }
}

class BinaryTree{
    private HeroNode root;
    public void setRoot(HeroNode root) {
        this.root = root;
    }
    // 前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空， 无法遍历");
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    // 后续遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
}

// 先创建HeroNode节点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left; // 默认null
    private HeroNode right; // 默认null

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }
    // 编写前序遍历的方法
    public void preOrder(){
        System.out.println(this); // 先输出父节点
        // 递归向左子数遍历
        if (this.left != null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null){
            this.right.preOrder();
        }
    }
    // 中序遍历
    public void infixOrder(){
        // 递归向左子树中序遍历
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    // 后序遍历
    public void postOrder(){
        if (this.left != null){
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}
```

### 二叉树-查找指定节点

1) 请编写前序查找，中序查找和后序查找的方法。
2) 并分别使用三种查找方式，查找 heroNO = 5 的节点
3) 并分析各种查找方式，分别比较了多少次
4) 思路分析图解

![image-20220309210947121](images\image-20220309210947121.png)

```java
package com.harry.datastructure.tree;

import com.sun.org.apache.bcel.internal.generic.IF_ACMPEQ;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        //先需要创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建需要的结点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
        //说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);

        //测试
//        System.out.println("前序遍历"); // 1,2,3,5,4
//        binaryTree.preOrder();
//        //测试
//        System.out.println("中序遍历");
//        binaryTree.infixOrder(); // 2,1,5,3,4
//        //
        System.out.println("后序遍历");
        binaryTree.postOrder(); // 2,5,4,3,1

//        HeroNode resNode = binaryTree.preOderSearch(5);
//        HeroNode resNode = binaryTree.infixOrderSearch(5);
        HeroNode resNode = binaryTree.postOrderSearch(5);
        if (resNode != null){
            System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());
        }else {
            System.out.printf("没有找到 no = %d 的英雄", 5);
        }


    }
}

class BinaryTree{
    private HeroNode root;
    public void setRoot(HeroNode root) {
        this.root = root;
    }
    // 前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空， 无法遍历");
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    // 后续遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    // 前序查找
    public HeroNode preOderSearch(int no){
        if (root != null){
            return root.preOrderSearch(no);
        }else {
            return null;
        }
    }

    //中序查找
    public HeroNode infixOrderSearch(int no){
        if (root != null){
            return root.infixOrderSearch(no);
        }else {
            return null;
        }
    }

    // 后续查找
    public HeroNode postOrderSearch(int no){
        if (root != null){
            return root.postOrderSearch(no);
        }else {
            return null;
        }
    }
}

// 先创建HeroNode节点
class HeroNode {
    private int no;
    private String name;
    private HeroNode left; // 默认null
    private HeroNode right; // 默认null

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }
    // 编写前序遍历的方法
    public void preOrder(){
        System.out.println(this); // 先输出父节点
        // 递归向左子数遍历
        if (this.left != null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right != null){
            this.right.preOrder();
        }
    }
    // 中序遍历
    public void infixOrder(){
        // 递归向左子树中序遍历
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    // 后序遍历
    public void postOrder(){
        if (this.left != null){
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    /**
     *
     * @param no 查找no
     * @return 如果没找到返回该Node， 如果没有找到返回null
     */
    public HeroNode preOrderSearch(int no){
        System.out.println("进入前序遍历");
        // 比较当前节点是不是
        if (this.no == no){
            return this;
        }
        // 1.判断当前节点的左子节点是否为空，如果不为空则递归前序查找
        // 2.如果左递归前序查找，找到节点，则返回
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){
            // 说明我们左子树找到
            return resNode;
        }
        // 1.左递归前序查找，找到节点，则返回，否则继续判断
        // 2.当前的节点的右子节点是否为空，如果不空，则继续向右递归前序查找
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode infixOrderSearch(int no ){
        // 判断当前节点的左子节点是否为空，如果不为空，则递归中查找
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        System.out.println("进入中序查找");
        if (this.no == no){
            return this;
        }

        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }

    // 后续遍历查找
    public HeroNode postOrderSearch(int no){
        // 判断当前节点的左子节点是否为空， 如果不为空，则递归后序查找
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode != null){
            // 在左子树找到了
            return resNode;
        }
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        System.out.println("进入后序查找");
        // 如果左右子树都没找到，就比较当前节点是不是
        if (this.no == no ){
            return this;
        }
        return resNode;
    }
}
```

### 二叉树-删除节点

1) 如果删除的节点是叶子节点，则删除该节点
2) 如果删除的节点是非叶子节点，则删除该子树

3) 测试，删除掉 5 号叶子节点 和 3 号子树.
4) 完成删除思路分析

![image-20220310205816453](images\image-20220310205816453.png)

```java
    public void delNode(int no){
        if (root != null){
            //如果只有一个 root 结点, 这里立即判断 root 是不是就是要删除结点
            if(root.getNo() == no) {
                root = null;
            } else {
                //递归删除
                root.delNode(no);
            }
        }else {
            return;
        }
    }
```

node递归删除

```java
   // 递归删除节点
    // 1 如果删除的节点是叶子节点则删除该节点
    // 2 如果删除的节点是非叶子节点，则删除该子树
    public void delNode(int no){
        /*
         * 1.因为我们的二叉树是单向的，所以我们是判断当前节点的子节点是否需要删除节点，而不能去判断当前这个节点是不是需要删除节点。
         * 2.如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left=null 并且返回(结束递归删除)
         * 3.如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就将this.right=null,并且就返回(结束递归删除)
         * 4.如果第2和第3步没有删除节点，那么我们就需要向子节点进行递归删除
         * 5.如果第4步也没有删除节点，则应当向右子树进行递归删除.
         */

        //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回(结束递归删除)
        if (this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        //3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回(结束递归删除)
        if (this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if (this.left != null){
            this.left.delNode(no);
        }
        if (this.right != null){
            this.right.delNode(no);
        }

    }
```

## 2、顺序存储二叉树

### 顺序存储二叉树的概念

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，
看右面的示意图

![image-20220311103423891](images\image-20220311103423891.png)

要求:
1) 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]
2) 要求在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历



顺序存储二叉树的特点:

1) 顺序二叉树通常只考虑完全二叉树
2) 第 n 个元素的左子节点为 2 * n + 1
3) 第 n 个元素的右子节点为 2 * n + 2
4) 第 n 个元素的父节点为 (n-1) / 2
5) n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)

### 顺序存储二叉树遍历

需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为
1,2,4,5,3,6,7

```java
package com.harry.datastructure.tree;

public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = { 1, 2, 3, 4, 5, 6, 7 };
        //创建一个 ArrBinaryTree
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
//        arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7
//        arrBinaryTree.infixOrder(0);
        arrBinaryTree.postOrder(0);
    }
}

class ArrBinaryTree{
    private int[] arr; // 存储数据节点的数组

    public ArrBinaryTree(int[] arr){
        this.arr = arr;
    }

    public void preOrder() {
        this.preOrder(0);
    }
    /***
     * 编写一个方法，完成顺序存储二叉树的前序遍历
     * @param index
     */
    public void preOrder(int index){
        // 如果数组为空，或者arr.length =0
        if (arr ==null || arr.length ==0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        System.out.println(arr[index]);

        // 向左遍历
        if (2*index +1 < arr.length){
            this.preOrder(2*index +1);
        }
        // 向右遍历
        if (index*2 +2 < arr.length){
            this.preOrder(2*index+2);
        }

    }

    public void infixOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        if (index * 2+1 < arr.length){
            this.infixOrder(index*2+1);
        }
        System.out.println(arr[index]);
        if (index*2+2 < arr.length){
            this.infixOrder(index*2+2);
        }
    }

    public void postOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        if (index * 2+1 < arr.length){
            this.postOrder(index*2+1);
        }
        if (index*2+2 < arr.length){
            this.postOrder(index*2+2);
        }
        System.out.println(arr[index]);
    }
}
```

## 3、线索化二叉树

将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7

![image-20220312193328785](images\image-20220312193328785.png)

1) 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }
2) 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.
3) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?
4) 解决方案-线索二叉树

### 线索二叉树基本介绍

1) n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向
该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）
2) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质
的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
3) 一个结点的前一个结点，称为前驱结点
4) 一个结点的后一个结点，称为后继结点

### 线索二叉树应用案例

应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}

![image-20220312193516469](images\image-20220312193516469.png)

![image-20220312193605943](images\image-20220312193605943.png)

说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:
	1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的
就是前驱节点.
	2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向
的是后继节点.

```java
package com.harry.datastructure.tree;

import com.sun.deploy.ui.AboutDialog;

public class ThreadBinaryTreeDemo {
    public static void main(String[] args) {
        //测试一把中序线索二叉树的功能

        ThreadBinaryTree.HeroNode2 root = new ThreadBinaryTree.HeroNode2(1, "tom");
        ThreadBinaryTree.HeroNode2 node2 = new ThreadBinaryTree.HeroNode2(3, "jack");
        ThreadBinaryTree.HeroNode2 node3 = new ThreadBinaryTree.HeroNode2(6, "smith");
        ThreadBinaryTree.HeroNode2 node4 = new ThreadBinaryTree.HeroNode2(8, "mary");
        ThreadBinaryTree.HeroNode2 node5 = new ThreadBinaryTree.HeroNode2(10, "king");
        ThreadBinaryTree.HeroNode2 node6 = new ThreadBinaryTree.HeroNode2(14, "dim");

        //二叉树，后面我们要递归创建, 现在简单处理使用手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        //测试中序线索化
        ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree();
        threadBinaryTree.setRoot(root);
        threadBinaryTree.threadedNodes(root);

        //测试: 以 10 号节点测试
        ThreadBinaryTree.HeroNode2 leftNode = node5.getLeft();
        ThreadBinaryTree.HeroNode2 rightNode = node5.getRight();
        System.out.println("10 号结点的前驱结点是 =" + leftNode); //3
        System.out.println("10 号结点的后继结点是=" + rightNode); //1

        //当线索化二叉树后，能在使用原来的遍历方法
        //threadedBinaryTree.infixOrder();
        System.out.println("使用线索化的方式遍历 线索化二叉树");
        threadBinaryTree.threadList(); // 8, 3, 10, 1, 14, 6
    }


}

class ThreadBinaryTree{
    private HeroNode2 root;

    // 为了实现线索化，需要创建要给指向当前节点的前驱节点的指针
    // 在递归进行线索化时，pre总是保留一个节点
    private HeroNode2 pre = null;


    public void setRoot(HeroNode2 root){
        this.root = root;
    }
    // 遍历线索化二叉树的方法
    public void threadList(){
        // 定义一个变量，存储当前遍历的节点，从root开始
        HeroNode2 node = root;
        while (node != null){
            // 循环的找到leftType ==1的节点，第一个找到就是8节点
            // 后面随着遍历而变化，因为当leftType==1时，说明该节点是按照线索化
            // 处理后的有序节点
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }

            // 打印当前这个节点
            System.out.println(node);
            // 如果当前节点的右指针指向的是后继节点就一直输出
            while (node.getRightType() == 1){
                // 获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }
            // 替换这个遍历的节点
            node = node.getRight();
        }
    }

    // 编写对二叉树进行中序线索化的方法
    public void threadedNodes(HeroNode2 node){
        // 如果 node ==null 不能线索化
        if (node ==null){
            return;
        }
        // 先线索化左子树
        threadedNodes(node.getLeft());
        // 线索化当前节点
        // 处理当前节点的前驱节点，以8节点来理解， 8的节点的left=null，8节点的leftTye ==1
        if (node.getLeft() == null){
            // 让当前节点的左指针向前驱节点
            node.setLeft(pre);
            node.setLeftType(1);
        }
        // 处理后续节点
        if (pre != null && pre.getRight() == null){
            // 让前驱节点的右指针指向当前节点
            pre.setRight(node);
            pre.setRightType(1);
        }
        // !!! 每处理一个节点后，让当前节点是一个节点的前驱节点
        pre = node;
        // 线索化右子树
        threadedNodes(node.getRight());

    }
    // 删除节点
    public void delNode(int no){
        if (root != null){
            //如果只有一个 root 结点, 这里立即判断 root 是不是就是要删除结点
            if(root.getNo() == no) {
                root = null;
            } else {
                //递归删除
                root.delNode(no);
        }
    }
}

static class HeroNode2{
    private int no;
    private String name;
    private HeroNode2 left;
    private HeroNode2 right;
    // 如果leftType ==0表示指向的是左子树，如果1则表示指向前驱节点
    // 如果rightType ==0表示指向的是右子树，如果1则表示指向前驱节点
    private int leftType;
    private int rightType;
    @Override
    public String toString() {
        return "HeroNode [no=" + no + ", name=" + name + "]";
    }
    public HeroNode2(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode2 getLeft() {
        return left;
    }

    public void setLeft(HeroNode2 left) {
        this.left = left;
    }

    public HeroNode2 getRight() {
        return right;
    }

    public void setRight(HeroNode2 right) {
        this.right = right;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    // 递归删除节点
    // 如果删除的节点是叶子节点，则删除该节点
    // 如果删除的节点是非叶子节点，则删除该子树
    public void delNode(int no){
        /***
         * 1 因为我们的二叉树是单向的，所以我们是判断当前节点的字节点是否需要删除，而不能去判断当前这个节点是不是需要删除节点
         * 2 如果当前节点的左子节点不为空，并且左子节点就是要删除节点，就将this.left =null，并且就返回(结束递归删除)
         * 3 如果当前节点的右子节点不为空，并且左子节点就是要删除节点，就将this.right =null，并且就返回(结束递归删除)
         * 4 如果第2和第3步没有删除节点，那么我们就需要左子树进行递归删除
         * 5 如果第4步也没有删除节点，则应当向右子树进行递归删除
         */
        if (this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if (this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if (this.left != null){
            this.left.delNode(no);
        }
        if (this.right != null){
            this.right.delNode(no);
        }

    }

}


}
```

### 遍历线索化二叉树

1) 说明：对前面的中序线索化的二叉树， 进行遍历
2) 分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历
线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次
序应当和中序遍历保持一致

```JAVA
// 遍历线索化二叉树的方法
    public void threadList(){
        // 定义一个变量，存储当前遍历的节点，从root开始
        HeroNode2 node = root;
        while (node != null){
            // 循环的找到leftType ==1的节点，第一个找到就是8节点
            // 后面随着遍历而变化，因为当leftType==1时，说明该节点是按照线索化
            // 处理后的有序节点
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }

            // 打印当前这个节点
            System.out.println(node);
            // 如果当前节点的右指针指向的是后继节点就一直输出
            while (node.getRightType() == 1){
                // 获取到当前节点的后继节点
                node = node.getRight();
                System.out.println(node);
            }
            // 替换这个遍历的节点
            node = node.getRight();
        }
    }

```

前序线索化二叉树和后序线索化二叉树的分析思路类似(待完成)

# 十、 树结构实际应用

## 1、堆排序

### 堆排序基本介绍

1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复
杂度均为 O(nlogn)，它也是不稳定排序。

2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有
要求结点的左孩子的值和右孩子的值的大小关系。

3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

4) 大顶堆举例说明

![image-20220312202852511](images\image-20220312202852511.png)

5) 小顶堆举例说明

![image-20220312202920106](images\image-20220312202920106.png)

6) 一般升序采用大顶堆，降序采用小顶堆

### 堆排序基本思想

堆排序的基本思想是：
1) 将待排序序列构造成一个大顶堆
2) 此时，整个序列的最大值就是堆顶的根节点。
3) 将其与末尾元素进行交换，此时末尾就为最大值。
4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序
序列了

可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了

### 堆排序步骤图解说明

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序

步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。

原始的数组 [4, 6, 8, 5, 9]
1) .假设给定无序序列结构如下

![image-20220312203114718](images\image-20220312203114718.png)

2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点
arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。

![image-20220312203154386](images\image-20220312203154386.png)

3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换

![image-20220312203259363](images\image-20220312203259363.png)

4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。

![image-20220312203318915](images\image-20220312203318915.png)

此时，我们就将一个无序序列构造成了一个大顶堆。
步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换得到第二大元素。如此反复进行交换、重建、交换。

1) .将堆顶元素 9 和末尾元素 4 进行交换

![image-20220312203407693](images\image-20220312203407693.png)

2) .重新调整结构，使其继续满足堆定义

![image-20220312203441751](images\image-20220312203441751.png)

3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8

![image-20220312203515013](images\image-20220312203515013.png)

4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![image-20220312203549128](images\image-20220312203549128.png)

再简单总结下堆排序的基本思路：

​	1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
​	2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
​	3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序

### 堆排序代码实现

```java
package com.harry.datastructure.sort;

import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        // 要求将数组进行升序排序
        int arr[] = {4,6,8,5,9};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));

    }
    public static void heapSort(int[] arr){
        int temp = 0;
        System.out.println("堆排序");
//        adjustHeap(arr, 1 ,arr.length);
//        System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6
//
//        adjustHeap(arr, 0, arr.length);
//        System.out.println("第 2 次" + Arrays.toString(arr)); // 9,6,8,5,4
        // 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for (int i= arr.length/2 -1; i >=0; i-- ){
            System.out.println("树顶" + arr[i]);
            adjustHeap(arr, i, arr.length);
        }

        for (int j = arr.length-1; j >0 ; j--) {
            // j 相当于数组最后一个元素， 要与第一个元素最交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            System.out.println("length" +j);
            adjustHeap(arr, 0, j);
        }

    }
    // 将一个数组(二叉树)调整成一个大顶推
    /**
     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆
     * 举例 int arr[] = {4, 6, 8, 5, 9}; => i = 1 => adjustHeap => 得到 {4, 9, 8, 5, 6}
     * 如果我们再次调用 adjustHeap 传入的是 i = 0 => 得到 {4, 9, 8, 5, 6} => {9,6,8,5, 4}
     * @param arr 待调整的数组
     * @param i 表示非叶子结点在数组中索引
     * @param length 表示对多少个元素继续调整， length 是在逐渐的减少
     */
    public static void adjustHeap(int[] arr, int i, int length) {
        //先取出当前元素的值，保存在临时变量(子树顶部的值)
        int temp = arr[i];
        for (int k = i * 2+1; k <length ; k = k*2+1) {
            System.out.println(arr[k] + ":" +k);
            //说明左子结点的值小于右子结点的值
            if (k + 1 < length && arr[k] < arr[k+1]){
                k++;
            }
            if (arr[k] > temp){
                //如果子结点大于父结点
                arr[i] = arr[k];//把较大的值赋给当前结点
                i = k; // !! i指向k,继续循环比较
            }else {
                break; // ! 重要
            }

        }
        //当for循环结束后， 我们已经将以i为父节点的树的最大值，放在了最顶(局部)
        arr[i] = temp; // 将temp值放置调整后的位置
    }
}

```

## 2、赫夫曼树

### 基本介绍

1) 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为
最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。

2) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近

### 赫夫曼树几个重要概念和举例说明

1) 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1

2) 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结
点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

3) 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path
length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

4) WPL 最小的就是赫夫曼树

![image-20220313180618178](images\image-20220313180618178.png)

### 赫夫曼树创建思路图解

给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树

#### 构成赫夫曼树的步骤：

1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树

2) 取出根节点权值最小的两颗二叉树

3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和

4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数
据都被处理，就得到一颗赫夫曼树

5) 图解:

![image-20220313181036200](images\image-20220313181036200.png)

#### 赫夫曼树的代码实现

```java
package com.harry.datastructure.huffmantree;

import java.util.ArrayList;
import java.util.Collections;

public class HuffmanTree {
    public static void main(String[] args) {
        int arr[] = { 13, 7, 8, 3, 29, 6, 1 };
        Node root = createHuffmanTree(arr);
        //测试一把
        preOrder(root); 
    }

    // 前序遍历
    public static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("是空树，不能遍历~");
        }
    }

    // 创建赫夫曼树
    /***
     * @param arr 需要创建成哈夫曼树的数组
     * @return 创建好后的赫夫曼树的 root 结点
     */
    public static Node createHuffmanTree(int[] arr){
        // 第一步为了操作方便， 1. 遍历arr数组 2. 将arr的每个元素构成成一个Node 3. 将Node放入到ArrayList
        ArrayList<Node> nodes = new ArrayList<>();
        for (int value : arr) {
            nodes.add(new Node(value));
        }
        // 我们处理的过程是一个循环的过程
        while (nodes.size() > 1){
            // 排序从小到大
            Collections.sort(nodes);

            System.out.println("nodes=" + nodes);
            //取出根节点权值最小的两颗二叉树
            //(1) 取出权值最小的结点（二叉树)
            Node left = nodes.get(0);
            //(2) 取出权值第二小的结点（二叉树）
            Node right = nodes.get(1);
            //(3) 构建一颗新的二叉树
            Node parent = new Node(left.value + right.value);
            parent.left = left;
            parent.right = right;
            nodes.remove(left);
            nodes.remove(right);

        }
        return nodes.get(0);
    }
}

// 创建节点
// 为了让 Node 对象持续排序 Collections 集合排序
// 让 Node 实现 Comparable 接口
class Node implements Comparable<Node>{
    int value; // 节点权值
    Node left;
    Node right;

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left != null){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }

    }
    public Node(int value) {
        this.value = value;
    }
    @Override
    public String toString() {
        return "Node [value=" + value + "]";
    }
    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

### 赫夫曼编码

1) 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法

2) 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。

3) 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间

4) 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码

#### 原理剖析

通信领域中信息的处理方式 1-定长编码

![image-20220313191143453](images\image-20220313191143453.png)

通信领域中信息的处理方式 2-变长编码

![image-20220313191204350](images\image-20220313191204350.png)

通信领域中信息的处理方式 3-赫夫曼编码

步骤如下;

> 传输的 字符串
> 1) i like like like java do you like a java
> 2) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数
> 3) 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值
> 步骤：
> 构成赫夫曼树的步骤：
> 1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
>
> 2) 取出根节点权值最小的两颗二叉树
>
> 3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
>
> 4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

![image-20220313191319873](images\image-20220313191319873.png)

根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码如下:

o: 1000 u: 10010 d: 100110 y: 100111 i: 101
a : 110 k: 1110 e: 1111 j: 0000 v: 0001
l: 001 : 01
按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为 (注
意这里我们使用的无损压缩)
10101001101111011110100110111101111010011011110111101000011000011100110011110000110
01111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133
长度为 ： 133

原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%

此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性,赫夫曼编码是无损处理方案

#### 注意事项

注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是
一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样，比如: 如果我们让每次生成的新的二叉树总是排在权
值相同的二叉树的最后一个，则生成的二叉树为:

![image-20220313191921145](images\image-20220313191921145.png)

### 最佳实践-数据压缩(创建赫夫曼树)

将给出的一段文本，比如 "i like like like java do you like a java" ， 根据前面的讲的赫夫曼编码原理，对其进行数
据 压 缩 处 理 ， 形 式 如
"1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110"

步骤 1：根据赫夫曼编码压缩数据的原理，需要创建 "i like like like java do you like a java" 对应的赫夫曼树

1) 生成赫夫曼树对应的赫夫曼编码 , 如下表:
=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=001

2) 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将"i like like like java do you like a java"
字符串生成对应的编码数据, 形式如下.
1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100

压缩代码

```java
package com.harry.datastructure.huffmantree;

import com.sun.applet2.AppletParameters;

import java.util.*;

public class HuffmanCodeDemon {
    static Map<Byte, String> huffmanCodes = new HashMap<>();
    static StringBuilder stringBuilder = new StringBuilder();

    public static void main(String[] args) {
        String s = "i like like like java do you like a java";
        byte[] contentBytes = s.getBytes();
        System.out.println(contentBytes.length);
        byte[] huffmanzip = huffmanzip(contentBytes);
        System.out.println("压缩后的长度"+ huffmanzip.length);

    }
    public static  List<Node2> getNode(byte[] contentBytes){
        HashMap<Byte, Integer> countMap  = new HashMap<>();

        for (byte s2: contentBytes) {
            Integer count = countMap.get(s2);
            if (count == null){
                countMap.put(s2, 1);
            }else {
                countMap.put(s2,count+1);
            }
        }
        List<Node2> nodes = new ArrayList<>();
        for (Map.Entry<Byte, Integer> entry : countMap.entrySet()) {
            Node2 node = new Node2(entry.getKey(), entry.getValue());
            nodes.add(node);
        }
        return nodes;
    }
    //使用一个方法，将前面的方法封装起来，便于调用

    /***
     *
     * @param bytes 原始的字符串对应的字节数组
     * @return 经过Huffman编码处理后的字节数组
     */
    public static byte[] huffmanzip(byte[] bytes){
        // 得到nodes
        List<Node2> nodes = getNode(bytes);
        // 创建Huffman树
        Node2 huffmanTree = createHuffmanTree(nodes);
        //        huffmanTree.infixOrder();
        // 创建赫夫曼编码
        Map<Byte, String> huffmanCode = getCodes(huffmanTree);
        System.out.println(huffmanCode);
        // huffman编码后的bytes

        // 进行压缩
        byte[] huffmanCodeBytes = zip(bytes, huffmanCode);
        System.out.println("huffmanCodeBytes" + Arrays.toString(huffmanCodeBytes));
        return huffmanCodeBytes;

    }
    private static Node2 createHuffmanTree(List<Node2> nodes){
        while (nodes.size() > 1){
            Collections.sort(nodes);
            Node2 leftNode = nodes.get(0);
            Node2 rightNode = nodes.get(1);

            Node2 parent = new Node2(null, leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            nodes.add(parent);
            nodes.remove(leftNode);
            nodes.remove(rightNode);
        }
        return nodes.get(0);
    }
    // 编写一个方法，将字符串对应byte[]数组通过生成的赫夫曼编码标返回一个赫夫曼编码压缩后的byte[]

    /***
     *
     *
     * @param bytes 这是原始的字符串对应的byte[]
     * @param huffmanCodes 生成的赫夫曼编码的map
     * @return 返回赫夫曼编码处理后的byte[]
     * 举例      String s = "i like like like java do you like a java" >>byte[] contentBytes = s.getBytes();
     * 返回的是“i like like like java do you like a java” 对应的byte[]数组
     * huffmanCodeBytes[0] = 10101000(补码) => byte[推导 10101000 => 10100111(反码) => 11011000 = -88]
     *
     */
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes){
        // 1. 利用 huffmanCodes将bytes转成赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        // 遍历bytes数组
        for (byte b : bytes) {
            stringBuilder.append(huffmanCodes.get(b));
        }
        System.out.println(stringBuilder);
        // 将“101010001011111100...” 转成byte[]
        int len;
        // 也可以写成一句话 int len = (stringBuilder.length() +7) /8;
        if (stringBuilder.length() % 8 == 0){
            len = stringBuilder.length() /8;
        }else {
            len = stringBuilder.length() /8 +1;
        }
        // 创建存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0; //记录是第几个byte
        for (int i=0; i<stringBuilder.length(); i += 8){
            // 因为是每8位对应一个byte， 所以是步长加8
            String strByte;
            if (i +8 > stringBuilder.length()){
                // 不够8为了
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i, i+8);
            }
            // 将styByte转成一个byte，放入到huffmanCodeBytes
            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);
            index++;
        }
        return huffmanCodeBytes;
    }
    private static Map<Byte, String> getCodes(Node2 root){
        if (root == null){
            return null;
        }
        // 处理左子树
        getCodes(root.left, "0", stringBuilder);
        getCodes(root.right, "1", stringBuilder);
        return huffmanCodes;
    }
    /**
     * 功能： 将传入的node节点的所有叶子节点的赫夫曼编码得到，并放入到huffmanCodes集合
     * @param node 传入结点
     * @param code 路径： 左子结点是 0, 右子结点 1
     * @param stringBuilder 用于拼接路径
     */
    private static void getCodes(Node2 node, String code, StringBuilder stringBuilder){
        System.out.println(stringBuilder);
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        // 将code加入到stringBuilder2
        stringBuilder2.append(code);
        if (node != null){
            // 如果node ==null 不处理
            // 判断当前node是叶子节点还是非叶子节点
            if (node.data == null){
                // 非叶子节点
                // 递归处理
                // 向左递归
                getCodes(node.left, "0", stringBuilder2);
                // 向右递归
                getCodes(node.right, "1", stringBuilder2);
            }else{
                // 说明是一个叶子节点。;
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }

        }
    }

}
class Node2 implements Comparable<Node2>{
    int value; // 节点权值
    Node2 left;
    Node2 right;
    Byte data;

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left != null){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }

    }
    public void infixOrder(){
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if (this.left != null){
            this.left.postOrder();
        }
        if (this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }


    public Node2(Byte data , int value) {
        this.data = data;
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node [Data="+ data+":"+"value=" + value + "]";
    }
    @Override
    public int compareTo(Node2 o) {
        return this.value - o.value;
    }
}
```



1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100 =>>huffmanCodeBytes[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]

### 数据解压(使用赫夫曼编码解码)

使用赫夫曼编码来解码数据，具体要求是
1) 前面我们得到了赫夫曼编码和对应的编码
	byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]

2) 现在要求使用赫夫曼编码， 进行解码，又
    重新得到原来的字符串"i like like like java do you like a java"

```java
    public static void main(String[] args) {
        String s = "i like like like java do you like a java";
        byte[] contentBytes = s.getBytes();
        System.out.println(contentBytes.length);
        byte[] huffmanzip = huffmanzip(contentBytes);
        System.out.println("压缩后的长度"+ huffmanzip.length);
        byte[] decode = decode(huffmanCodes, huffmanzip);
        System.out.println(new String(decode));

    }
    
    /***
     * 将一个byte转成一个二进制的字符串，如果不懂参考二进制的源码，反码补码
     * @param b 传入的 byte
     * @param flag 标志是否需要补高位如果是 true ，表示需要补高位，如果是 false 表示不补, 如果是最后一个字节，无需补高位
     * @return 是该 b 对应的二进制的字符串，（注意是按补码返回
     */
    public static String byteTobitString(boolean flag, byte b){
        // 使用变量保存 b
        int temp = b; // 将b转成int
        // 如果是正数我们还存在补高位
        if (flag){
            temp |= 256; // 1 0000 0000 | 0000 0001 => 1 0000 0001
        }
        String str = Integer.toBinaryString(temp); // 返回的是tempp对应的二进制补码
        if (flag){
            return str.substring(str.length()-8);
        }else{
            return str;
        }

    }
    //编写一个方法，完成对压缩数据的解码
    /**
     *
     * @param huffmanCodes 赫夫曼编码表 map
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 就是原来的字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes, byte[] huffmanBytes) {
        // 1. 先得到huffmanBytes对应的二进制的字符串，形式101010001011.....
        StringBuilder stringBuilder = new StringBuilder();
        // 将byte数组转成二进制的字符串
        for (int i = 0; i <huffmanBytes.length ; i++) {
            byte b = huffmanBytes[i];
            // 判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length -1);
            stringBuilder.append(byteTobitString(!flag, b));
        }
        //把字符串安装指定的赫夫曼编码进行解码
        //把赫夫曼编码表进行调换，因为反向查询 a->100 100->a
        Map<String, Byte> map = new HashMap<String, Byte>();
        for (Map.Entry<Byte, String> byteStringEntry : huffmanCodes.entrySet()) {
            map.put(byteStringEntry.getValue(), byteStringEntry.getKey());
        }
        // 创建集合 存放byte
        List<Byte> list = new ArrayList<>();
        // i可以理解成就是索引，扫描stringBuilder
        for (int i = 0; i < stringBuilder.length();){
            int count = 1; // 小的计数器
            boolean flag = true;
            Byte b = null;

            while (flag){
                //1010100010111...
                //递增的取出 key 1
                String key = stringBuilder.substring(i, i+count);//i 不动，让 count 移动，指定匹配到一个字符
                b = map.get(key);
                if(b == null) {//说明没有匹配到
                    count++;
                }else {
                    //匹配到
                    flag = false;
                }
            }
            list.add(b);
            i+= count; // i 直接移动到count
        }
        // 放for循环后 我们list中就存放了所有的字符 "i like like like java do you like a java"
        // 把list中的数据放入到byte[] 并返回
        byte[] b = new byte[list.size()];
        for (int i = 0; i <b.length ; i++) {
            b[i] = list.get(i);
        }
        return b;
    }
```

### 最佳实践-文件压缩

我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：
给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。
1) 思路：读取文件-> 得到赫夫曼编码表 -> 完成压缩

```java
//编写方法，将一个文件进行压缩
    /**
     *
     * @param srcFile 你传入的希望压缩的文件的全路径
     * @param dstFile 我们压缩后将压缩文件放到哪个目录
     */
    public static void zipFile(String srcFile, String dstFile){
        // 创建输出流
        OutputStream os = null;
        ObjectOutputStream oos = null;
        // 创建文件的输入流
        FileInputStream is = null;
        try {
            // 创建文件的输入流
            is = new FileInputStream(srcFile);
            // 创建一个和源文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            // 读取文件
            is.read(b);
            // 直接对源文件压缩
            byte[] huffmanBytes = huffmanzip(b);
            // 创建文件的输出流， 存放到压缩文件
            os = new FileOutputStream(dstFile);
            // 创建一个和文件输出流关联的objectOutputStream
            oos = new ObjectOutputStream(os);
            // 把赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes);
            // 这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用
            // 注意一定要把赫夫曼编码写入压缩文件
            oos.writeObject(huffmanCodes);

        }catch (Exception e) {
            // TODO: handle exception
            System.out.println(e.getMessage());
        }finally {
            try {
                if (is != null) {
                    is.close();
                }
                if (oos != null) {
                    oos.close();
                }
                if (os != null) {
                    os.close();
                }
            }catch (Exception e) {
                // TODO: handle exception
                System.out.println(e.getMessage());
            }
        }

    }
```

### 文件解压(文件恢复)

具体要求：将前面压缩的文件，重新恢复成原来的文件。
1) 思路：读取压缩文件(数据和赫夫曼编码表)-> 完成解压(文件恢复)
2) 代码实现：

```java
/**
     *
     * @param zipFile 准备解压的文件
     * @param dstFile 将文件解压到哪个路径
     */
    public static void unZipFile(String zipFile, String dstFile){
        //定义文件输入流
        InputStream is = null;
        //定义一个对象输入流
        ObjectInputStream ois = null;
        //定义文件的输出流
        OutputStream os = null;
        try {
            // 创建文件输入流
            is = new FileInputStream(zipFile);
            // 创建一个和is关联的对象输入流
            ois = new ObjectInputStream(is);
            // 读取byte数组 huffmanBytes
            byte[] huffmanBytes = (byte[]) ois.readObject();
            // 读取赫夫曼码表
            Map<Byte, String> huffmanCodes = (Map<Byte, String>) ois.readObject();
            // 解码
            byte[] bytes = decode(huffmanCodes, huffmanBytes);
            // 将bytes数组写入到目标文件
            os = new FileOutputStream(dstFile);
            // 写数据到desFile
            os.write(bytes);
        }catch (Exception e) {
            // TODO: handle exception
            System.out.println(e.getMessage());
        } finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e2) {
                // TODO: handle exception
                System.out.println(e2.getMessage());
            }
        }
    }
```

### 赫夫曼编码压缩文件注意事项

1) 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件
[举例压一个 .ppt]
2) 赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml 文件]
3) 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显

## 3、二叉排序树

### 二叉排序树介绍

​      二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。
​    特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![image-20220315200709976](images\image-20220315200709976.png)

### 二叉排序树创建和遍历

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创
建成对应的二叉排序树为 :

![image-20220315200800579](images\image-20220315200800579.png)

### 二叉排序树的删除

叉排序树的删除情况比较复杂，有下面三种情况需要考虑
   1) 删除叶子节点 (比如：2, 5, 9, 12)
   2) 删除只有一颗子树的节点 (比如：1)
   3) 删除有两颗子树的节点. (比如：7, 3，10 )
   4) 操作的思路分析

> 对删除结点的各种情况的思路分析:
> 第一种情况:
> 删除叶子节点 (比如：2, 5, 9, 12)
> 思路
> (1) 需求先去找到要删除的结点 targetNode
> (2) 找到 targetNode 的 父结点 parent
> (3) 确定 targetNode 是 parent 的左子结点 还是右子结点
> (4) 根据前面的情况来对应删除
> 左子结点 parent.left = null
> 右子结点 parent.right = null;
>
> 
>
> 第二种情况: 删除只有一颗子树的节点 比如 1
> 思路
> (1) 需求先去找到要删除的结点 targetNode
> (2) 找到 targetNode 的 父结点 parent
> (3) 确定 targetNode 的子结点是左子结点还是右子结点
> (4) targetNode 是 parent 的左子结点还是右子结点
> (5) 如果 targetNode 有左子结点
>
>    1 如果 targetNode 是 parent 的左子结点  parent.left = targetNode.left;
>    2 如果 targetNode 是 parent 的右子结点  parent.right = targetNode.left;
>
> (6) 如果 targetNode 有右子结点
>       1 如果 targetNode 是 parent 的左子结点  parent.left = targetNode.right;
>       2 如果 targetNode 是 parent 的右子结点  parent.right = targetNode.right
>
> 
>
> 情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )
> 思路
> (1) 需求先去找到要删除的结点 targetNode
> (2) 找到 targetNode 的 父结点 parent
> (3) 从 targetNode 的右子树找到最小的结点
> (4) 用一个临时变量，将 最小结点的值保存 temp = 11
> (5) 删除该最小结点
> (6) targetNode.value = temp

```java
package com.harry.datastructure.binaryTree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7, 3, 10, 12, 5, 1, 9, 2, 4};
        BinarySortTree binarySortTree = new BinarySortTree();
        //循环的添加结点到二叉排序树
        for(int i = 0; i< arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
//        binarySortTree.infixOrder();

        //测试一下删除叶子结点
//        binarySortTree.delNode(12);
        binarySortTree.delNode(5);
        binarySortTree.delNode(10);
//        binarySortTree.delNode(2);
//        binarySortTree.delNode(3);
        binarySortTree.delNode(9);
        binarySortTree.delNode(1);
        binarySortTree.delNode(7);
        System.out.println("root=" + binarySortTree.getRoot());
        System.out.println("删除结点后");
        binarySortTree.infixOrder();
    }
}

// 创建二叉排序树
class BinarySortTree{
    Node root;

    public Node getRoot() {
        return root;
    }

    public  void add(Node node){
        if (root ==null){
            root = node;
        }else {
            root.add(node);
        }

    }
    public void infixOrder(){
        if (root !=null){
            root.infixOrder();
        }
    }
    // 查找要删除的节点
    public Node search(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }
    // 删除节点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1. 需求先去找到要删除的节点 targetNode
            Node targetNode = search(value);
            // 如果没有找到要删除的节点
            if (targetNode == null){
                return;
            }
            // 如果我们发现当前这颗二叉排序树只有一个节点
            if (root.left == null && root.right == null){
                root = null;
                return;
            }
            // 去找到targetNode的父节点
            Node parent = searchParent(value);
            // 如果要删除的节点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                /***
                 * (1) 需求先去找到要删除的结点 targetNode
                 * (2) 找到 targetNode 的 父结点 parent
                 * (3) 确定 targetNode 是 parent 的左子结点 还是右子结点
                 * (4) 根据前面的情况来对应删除
                 *  左子结点 parent.left = null
                 *  右子结点 parent.right = null;
                 */
                // 判断targetNode是父节点的左子节点，还是右子节点
                if (parent.left != null && parent.left.value == targetNode.value){
                    parent.left = null;
                }else if (parent.right !=null && parent.right.value == targetNode.value){
                    parent.right = null;
                }
            }else if (targetNode.left != null && targetNode.right!= null){
                // 删除有两颗子树的节点
                /***
                 *  1) 需求先去找到要删除的结点 targetNode
                 *  2) 找到 targetNode 的 父结点 parent
                 *  3) 从 targetNode 的右子树找到最小的结点
                 *  4) 用一个临时变量，将 最小结点的值保存 temp = 11
                 *  5) 删除该最小结点
                 *  6) targetNode.value = temp
                 */
                int minVal = delRightTreeMin(targetNode.right);
                // 把最小节点的值放到当前节点
                targetNode.value = minVal;
            }else {
                // 删除只有一颗子树的节点
                // 如果要删除的节点有左子节点
                /***
                 * (1) 需求先去找到要删除的结点 targetNode
                 * (2) 找到 targetNode 的 父结点 parent
                 * (3) 确定 targetNode 的子结点是左子结点还是右子结点
                 * (4) targetNode 是 parent 的左子结点还是右子结点
                 * (5) 如果 targetNode 有左子结点
                 */
                if (targetNode.left !=null){

                    if (parent != null){
                        // 如果targetNode 是parent的左子节点
                        if (parent.left != null && parent.left.value == value){
                            //1 如果 targetNode 是 parent 的左子结点  parent.left = targetNode.left;
                            parent.left = targetNode.left;
                        }else {
                            //2 如果 targetNode 是 parent 的右子结点  parent.right = targetNode.left;
                            // targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }
                }else {
                    // 如果要删除的结点有右子结点
                    if (parent !=null){
                        if ( parent.left != null &&parent.left.value == value){
                            // targetNode是parent的左子节点
                            parent.left = targetNode.right;
                        }else {
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }
    //1. 返回的以code为根节点的二叉排序树的最小节点的值
    //2. 删除node为根节点的二叉排序树的最小节点

    /***
     *
     * @param node 传入的节点(当做二叉排序树的根节点)
     * @return 返回的以node为根节点的二叉排序树的最小节点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        // 循环的查找左子节点，就会找到最小值
        while (target.left !=null){
            target = target.left;
        }
        // 这时target就指向了最小节点
        // 删除最小的节点
        delNode(target.value);
        return target.value;
    }

}

//
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    // 查找要删除的节点
    /***
     *
     */
    public Node search(int value){
        if (value == this.value){
            return this; // 找到就是该节点
        }else if (value < this.value){
            // 如果查找的值小于当前节点 向左子树递归查找
            if (this.left == null){
                return null;
            }
            return this.left.search(value);
        }else {
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }

    }

    // 查找要删除节点的父节点
    public Node searchParent(int value){
        if ((this.left != null &&this.left.value == value) || (this.right!= null && this.right.value ==value)){
            return this;
        }else {
            // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left !=null){
                return this.left.searchParent(value);
            }else if (value > this.value && this.right != null){
                return this.right.searchParent(value); // 向右子树递归查找
            }else {
                return  null; // 没有找到父节点
            }
        }
    }
    //添加结点的方法
    //递归的形式添加结点，注意需要满足二叉排序树的要求
    public void add(Node node){
        if (node == null){
            return;
        }
        if (node.value < this.value ){
            if (this.left == null){
                this.left = node;
            }else {
                this.left.add(node);
            }
        }else {
            if (this.right == null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
    }
    public void infixOrder(){
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    @Override
    public String toString() {
        return "Node [value=" + value + "]";
    }
}
```

找当前节点的左子树的最大值

```java
   public int delLeftTreeMax(Node node){
        Node target = node;
        while (target.right != null){
            target = target.right;
        }
        delNode(target.value);
        return target.value;
    }
    
    // 删除节点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1. 需求先去找到要删除的节点 targetNode
            Node targetNode = search(value);
            // 如果没有找到要删除的节点
            if (targetNode == null){
                return;
            }
            // 如果我们发现当前这颗二叉排序树只有一个节点
            if (root.left == null && root.right == null){
                root = null;
                return;
            }
            // 去找到targetNode的父节点
            Node parent = searchParent(value);
            // 如果要删除的节点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                /***
                 * (1) 需求先去找到要删除的结点 targetNode
                 * (2) 找到 targetNode 的 父结点 parent
                 * (3) 确定 targetNode 是 parent 的左子结点 还是右子结点
                 * (4) 根据前面的情况来对应删除
                 *  左子结点 parent.left = null
                 *  右子结点 parent.right = null;
                 */
                // 判断targetNode是父节点的左子节点，还是右子节点
                if (parent.left != null && parent.left.value == targetNode.value){
                    parent.left = null;
                }else if (parent.right !=null && parent.right.value == targetNode.value){
                    parent.right = null;
                }
            }else if (targetNode.left != null && targetNode.right!= null){
                // 删除有两颗子树的节点
                /***
                 *  1) 需求先去找到要删除的结点 targetNode
                 *  2) 找到 targetNode 的 父结点 parent
                 *  3) 从 targetNode 的右子树找到最小的结点
                 *  4) 用一个临时变量，将 最小结点的值保存 temp = 11
                 *  5) 删除该最小结点
                 *  6) targetNode.value = temp
                 */
//                int minVal = delRightTreeMin(targetNode.right);
                int maxVal = delLeftTreeMax(targetNode.left);
                // 把最小节点的值放到当前节点
                targetNode.value = maxVal;
            }else {
                // 删除只有一颗子树的节点
                // 如果要删除的节点有左子节点
                /***
                 * (1) 需求先去找到要删除的结点 targetNode
                 * (2) 找到 targetNode 的 父结点 parent
                 * (3) 确定 targetNode 的子结点是左子结点还是右子结点
                 * (4) targetNode 是 parent 的左子结点还是右子结点
                 * (5) 如果 targetNode 有左子结点
                 */
                if (targetNode.left !=null){

                    if (parent != null){
                        // 如果targetNode 是parent的左子节点
                        if (parent.left != null && parent.left.value == value){
                            //1 如果 targetNode 是 parent 的左子结点  parent.left = targetNode.left;
                            parent.left = targetNode.left;
                        }else {
                            //2 如果 targetNode 是 parent 的右子结点  parent.right = targetNode.left;
                            // targetNode是parent的右子节点
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }
                }else {
                    // 如果要删除的结点有右子结点
                    if (parent !=null){
                        if ( parent.left != null &&parent.left.value == value){
                            // targetNode是parent的左子节点
                            parent.left = targetNode.right;
                        }else {
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }
```

## 4、平衡二叉树(AVL 树)

给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.

左边 BST 存在的问题分析:

1) 左子树全部为空，从形式上看，更像一个单链表.
2) 插入速度没有影响
3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比
单链表还慢

4) 解决方案-平衡二叉树(AVL)

### 基本介绍

1) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。
2) 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵
平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。
3) 举例说明, 看看下面哪些 AVL 树, 为什么?

![image-20220316210058751](images\image-20220316210058751.png)

### 应用案例-单旋转(左旋转)

1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}
2) 思路分析(示意图)

![image-20220316210253416](images\image-20220316210253416.png)

```java
    // 左旋方法
    public void leftRotate(){
        // 创建新的节点，以当前根节点的值
        Node newNode = new Node(value);
        // 把新的节点的左子树设置成当前节点的右子树
        newNode.left = this.left;
        // 把新的节点的右子树设置成带过去节点的右子树的左子树
        newNode.right = this.right.left;
        // 把当前节点的值替换成右子树节点的值
        this.value = this.right.value;
        // 把当前节点的右子树设置成当前节点右子树的右子树
        this.right = this.right.right;
        // 把当前节点的左子树(左子节点)设置成新的节点
        this.left = newNode;
    }
```

### 应用案例-单旋转(右旋转）

1) 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}
2) 思路分析(示意图)

![image-20220317193934916](images\image-20220317193934916.png)

```java
  // 右旋转
    private void rightRotate(){
        Node newNode = new Node(value);
        newNode.right = this.right;
        newNode.left = this.left.right;
        this.value = this.left.value;
        this.left = this.left.left;
        this.right = newNode;
    }
```

### 应用案例-双旋转

前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转
不能完成平衡二叉树的转换。比如数列

int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.
int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL 树

![image-20220317194451390](images\image-20220317194451390.png)

 解决思路分析

​	当符号右旋转的条件时

​	如果它的左子树的右子树高度大于它的左子树的高度

​	先对当前这个结点的左节点进行左旋转

​	再对当前结点进行右旋转的操作即可

代码实现[AVL 树的汇总代码(完整代码)]

```java
package com.harry.datastructure.avl;

public class AVLTreeDemo {
    public static void main(String[] args) {
//        int[] arr = {4,3,6,5,7,8};
        //int[] arr = { 10, 12, 8, 9, 7, 6 };
        int[] arr = {10, 11, 7, 6, 8, 9 };
        //创建一个 AVLTree 对象
        AVLTree avlTree = new AVLTree();
        //添加结点
        for(int i=0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }
        //遍历
        System.out.println("中序遍历");
        avlTree.infixOrder();
        System.out.println("在平衡处理~~");
        System.out.println("树的高度=" + avlTree.getRoot().height()); //3
        System.out.println("树的左子树高度=" + avlTree.getRoot().leftHeight()); // 2
        System.out.println("树的右子树高度=" + avlTree.getRoot().rightHeight()); // 2
        System.out.println("当前的根结点=" + avlTree.getRoot());// 8
    }
}


// 创建AVLTree
class AVLTree{
    private Node root;
    public Node getRoot(){
        return root;
    }
    public void infixOrder(){
        if (root !=null){
            root.infixOrder();
        }
    }
    public Node search(int value){
        if (root == null){
            return  null;
        }else {
            return root.search(value);
        }
    }
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }
    // 添加结点的方法
    public void add(Node node) {
        if (root == null) {
            root = node;// 如果 root 为空则直接让 root 指向 node
        } else {
            root.add(node);
        }
    }
}
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value){
        this.value = value;
    }
    public void add(Node node){
        if (node == null){
            return;
        }
        if (node.value < this.value){
            if (this.left == null){
                this.left = node;
            }else {
                this.left.add(node);
            }

        }else {
            if (this.right == null){
                this.right = node;
            }else {
                this.right.add(node);
            }
        }
        //当添加完一个结点后，如果: (右子树的高度-左子树的高度) > 1 , 左旋转
        if (rightHeight() - leftHeight() > 1){
            System.out.println("左旋");
            // 如果他的右子树的左子树的高度大于它的右子树的右子树的高度
            if (this.right != null && this.right.leftHeight() > this.right.rightHeight()){
                // 先对右子节点进行右旋转
                this.right.rightRotate();
                //然后在对当前节点进行左旋转
                this.leftRotate();
            }else {
                // 直接进行左旋转即可
                leftRotate();
            }
            return; // 必须要return一下！！
        }
        // 当添加完一个节点后， 如果(左子树的高度-右子树的高度)>1 右旋转
        if (leftHeight() - rightHeight() > 1) {
            System.out.println("右旋" + value);
            if (left != null && this.left.rightHeight() > this.left.leftHeight()){
                // 先对当前节点的左节点（左子树）左旋转
                this.left.leftRotate();
                // 再对当前节点进行右旋转
                this.rightRotate();
            }else {
                this.rightRotate();
            }
        }
    }
    public Node searchParent(int value){
        if ((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前节点的值，并且当前节点的左子节点不为空
            if (value < this.value && this.left !=null){
                return this.left.searchParent(value);
            }else if (value > this.value && this.right != null){
                return this.right.searchParent(value); // 向右子树递归查找
            }else {
                return  null; // 没有找到父节点
            }
        }

    }
    public Node search(int value){
        if (value == this.value){
            return this; // 找到就是该节点
        }else if (value < this.value){
            // 如果查找的值小于当前节点 向左子树递归查找
            if (this.left == null){
                return null;
            }
            return this.left.search(value);
        }else {
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }
        return left.height();
    }
    public int rightHeight(){
        if (right == null){
            return 0;
        }
        return right.height();
    }

    public int height(){
        return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
    }

    // 左旋方法
    public void leftRotate(){
        // 创建新的节点，以当前根节点的值
        Node newNode = new Node(value);
        // 把新的节点的左子树设置成当前节点的右子树
        newNode.left = this.left;
        // 把新的节点的右子树设置成带过去节点的右子树的左子树
        newNode.right = this.right.left;
        // 把当前节点的值替换成右子树节点的值
        this.value = this.right.value;
        // 把当前节点的右子树设置成当前节点右子树的右子树
        this.right = this.right.right;
        // 把当前节点的左子树(左子节点)设置成新的节点
        this.left = newNode;
    }
    // 右旋转
    private void rightRotate(){
        Node newNode = new Node(value);
        newNode.right = this.right;
        newNode.left = this.left.right;
        this.value = this.left.value;
        this.left = this.left.left;
        this.right = newNode;
    }

    public void infixOrder(){
        if (this.left !=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
    @Override
    public String toString() {
        return "Node [value=" + value + "]";
    }
}
```

# 十一、多路查找树

## 1、二叉树与 B 树

### 二叉树的问题分析

二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树

![image-20220318192927421](images\image-20220318192927421.png)

1) 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就
存在如下问题:

2) 问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，
速度有影响

3) 问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度

### 多叉树

1) 在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，
就是多叉树（multiway tree）
2) 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。
3) 举例说明(下面 2-3 树就是一颗多叉树)

![image-20220318193233776](images\image-20220318193233776.png)

## 2、B 树的基本介绍

B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率

![image-20220318193323348](images\image-20220318193323348.png)

1) 如图 B 树通过重新组织节点， 降低了树的高度.

2) 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为 4k)，这样每个节点只需要一次 I/O 就可以完全载入

3) 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, B 树(B+)广泛
应用于文件存储系统以及数据库系统中

### 2-3 树

2-3 树是最简单的 B 树结构, 具有如下特点：

1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)

2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点

3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.

4) 2-3 树是由二节点和三节点构成的树

### 2-3 树应用案例

将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。(演示一下构建 2-3树的过程.)

![image-20220318193847833](images\image-20220318193847833.png)

插入规则:
1) 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)

2) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.

3) 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点

4) 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件。

5) 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则

### 其它说明

除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:

![image-20220318194100635](images\image-20220318194100635.png)

## 3、B 树、B+树和 B*树

### B 树的介绍

B-tree 树即 B 树，B 即 Balanced，平衡的意思。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树
是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树

前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学
习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:

![image-20220318194433698](images\image-20220318194433698.png)

1) B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4

2) B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询
关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

3) 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.

4) 搜索有可能在非叶子结点结束

5) 其搜索性能等价于在关键字全集内做一次二分查找

### B+树的介绍

B+树是 B 树的变体，也是一种多路搜索树。

![image-20220318194855784](images\image-20220318194855784.png)

对上图的说明:

1) B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性
能也等价于在关键字全集做一次二分查找

2) 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)
恰好是有序的。

3) 不可能在非叶子结点命中

4) 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层

5) 更适合文件索引系统

6) B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然.

### B*树的介绍

B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针。

![image-20220318195115767](images\image-20220318195115767.png)

1) B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的
1/2。
2) 从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高

# 十二、图

## 1、图基本介绍

为什么要有图

1) 前面我们学了线性表和树
2) 线性表局限于一个直接前驱和一个直接后继的关系
3) 树也只能有一个直接前驱也就是父节点
4) 当我们需要表示多对多的关系时， 这里我们就用到了图

### 图的举例说明

图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为
顶点。如图：

![image-20220318195427136](images\image-20220318195427136.png)

### 图的常用概念

1) 顶点(vertex)
2) 边(edge)
3) 路径
4) 无向图(右图

![image-20220318195527538](images\image-20220318195527538.png)

5) 有向图
6) 带权图

![image-20220318195551993](images\image-20220318195551993.png)

## 2、图的表示方式

图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。

### 邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n
个点。

![image-20220318195719326](images\image-20220318195719326.png)

### 邻接表

1) 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失.

2) 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成

3) 举例说明

![image-20220318195805683](images\image-20220318195805683.png)

```JAVA
package com.harry.datastructure.graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {
    private ArrayList<String> vertexList; // 存储顶点集合
    private int[][] edges; // 存储图对应的邻结矩阵
    private int numOfEdges; // 表示边的数目
    // 定义给数组boolean[] 记录某个节点是否被访问
    private boolean[] isVisited;

    public static void main(String[] args) {
        // 测试图是不是创建OK
        int n = 5; // 节点的个数
        String Vertexs[] = {"A", "B", "C", "D", "E"};
        // 创建图对象
        Graph graph = new Graph(n);
        // 循环的添加顶点
        for(String vertex: Vertexs) {
            graph.insertVertex(vertex);
        }
         //添加边
         //A-B A-C B-C B-D B-E
         graph.insertEdge(0, 1, 1); // A-B
         graph.insertEdge(0, 2, 1); // A-C
         graph.insertEdge(1, 2, 1); // B-C
         graph.insertEdge(1, 3, 1); // B-D
         graph.insertEdge(1, 4, 1); // B-E

         graph.showGraph();

    }
    // 构造器
    public Graph(int n){
        // 初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
    }


    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /***
     *
     * @param v1 表示点的下标即第几个顶点 “A”-“B” “A”->0 "B"->1
     * @param v2
     * @param weight
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
    // 显示图对应的矩阵
    public void showGraph(){
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }

    // 图中常用的方法
    // 返回节点的个数
}
```

### 图的深度优先遍历介绍

所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种
访问策略: (1)深度优先遍历 (2)广度优先遍历

#### 深度优先遍历基本思想

1) 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问
第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：
每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。

2) 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。

3) 显然，深度优先搜索是一个递归的过程

#### 深度优先遍历算法步骤

1) 访问初始结点 v，并标记结点 v 为已访问。

2) 查找结点 v 的第一个邻接结点 w。

3) 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。

4) 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。

5) 查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。

6) 分析图

![image-20220319194150055](images\image-20220319194150055.png)

#### 深度优先算法的代码实现

```java
//i 第一次就是 0
    private void dfs(boolean[] isVisited, int i){
        // 首先我们访问该节点输出
        System.out.print(getValueByIndex(i) + "->");
        // 将节点设置为已访问
        isVisited[i] = true;
        // 查找节点i的第一个邻接节点w
        int w = getFirstNeighbor(i);
        while (w != -1){
            // 说明找到了下一个邻接节点
            if (!isVisited[w]){
                // 如果下一个邻接节点没被访问过， 那么就用这个节点继续递归
                dfs(isVisited, w);
            }
            // 如果w节点已经被访问过。 就继续往下找节点
            w = getNextNeighbor(i, w);
        }
    }
    // 对dfs进行一个重载，遍历我们所有的节点， 并进行dfs
    public void dfs(){
        isVisited = new boolean[vertexList.size()];
        for (int i = 0; i <getNumOfVertex(); i++) {
            if (!isVisited[i]){
                dfs(isVisited, i);
            }
        }
    }
    public int getNumOfVertex(){
        return vertexList.size();
    }
    // 根据前一个邻接节点的下标来获取下一个临街节点
    private int getFirstNeighbor(int index){
        for (int i = 0; i < vertexList.size(); i++) {
            if (edges[index][i] >0){
                return i;
            }
        }
        return -1;
    }

    // 根据前一个邻接节点的下标来获取下一个邻接节点
    public int getNextNeighbor(int v1, int v2){
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0){
                return i;
            }
        }
        return -1;
    }

    private String getValueByIndex(int i){
        return vertexList.get(i);
    }
```



### 广度优先遍历基本思想

1) 图的广度优先搜索(Broad First Search) 。

2) 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来
访问这些结点的邻接结点

#### 广度优先遍历算法步骤

1) 访问初始结点 v 并标记结点 v 为已访问。

2) 结点 v 入队列

3) 当队列非空时，继续执行，否则算法结束。

4) 出队列，取得队头结点 u。

5) 查找结点 u 的第一个邻接结点 w。

6) 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤：

​	 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。

​	 结点 w 入队列

​	 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6

```java
   // 对一个节点进行广度优先遍历的方法
    public void bfs(boolean[] isVisited, int i){
        int u; // 表示队列的头结点对应下标
        int w; // 邻接节点w
        // 队列。记录结点访问的顺序
        LinkedList<Integer> queue = new LinkedList<Integer>();
        // 访问节点 输出结点信息
        System.out.print(getValueByIndex(i) + "=>");
        // 标记已访问
        isVisited[i] = true;
        // 将结点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()){
            // 取出队列的头结点下标
            u = queue.removeFirst();
            // 得到第一个邻接节点的下标w
            w = getFirstNeighbor(u);
            while (w != -1){
                // 找到
                // 是否访问过
                if (!isVisited[w]){
                    System.out.print(getValueByIndex(w) + "=>");
                    // 标记已经访问
                    isVisited[w] = true;
                    //  入队
                    queue.addLast(w);
                }
                // 以u为前驱节点，找w后面的下一个邻接节点
                w = getNextNeighbor(u, w); // 体现出广度
            }
        }
    }
    //遍历所有的结点，都进行广度优先搜索
    public void bfs(){
        isVisited = new boolean[vertexList.size()];
        for (int i = 0; i <getNumOfVertex(); i++) {
            if (!isVisited[i]){
                bfs(isVisited, i);
            }
        }
    }
```

### 图所有代码

```java
package com.harry.datastructure.graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph {
    private ArrayList<String> vertexList; // 存储顶点集合
    private int[][] edges; // 存储图对应的邻结矩阵
    private int numOfEdges; // 表示边的数目
    // 定义给数组boolean[] 记录某个节点是否被访问
    private boolean[] isVisited;

    public static void main(String[] args) {
        // 测试图是不是创建OK
        int n = 8; // 节点的个数
//        String Vertexs[] = {"A", "B", "C", "D", "E"};
        String Vertexs[] = {"1", "2", "3", "4", "5", "6", "7", "8"};
        // 创建图对象
        Graph graph = new Graph(n);
        // 循环的添加顶点
        for(String vertex: Vertexs) {
            graph.insertVertex(vertex);
        }
         //添加边
         //A-B A-C B-C B-D B-E
//         graph.insertEdge(0, 1, 1); // A-B
//         graph.insertEdge(0, 2, 1); // A-C
//         graph.insertEdge(1, 2, 1); // B-C
//         graph.insertEdge(1, 3, 1); // B-D
//         graph.insertEdge(1, 4, 1); // B-E


         //更新边的关系
         graph.insertEdge(0, 1, 1);
         graph.insertEdge(0, 2, 1);
         graph.insertEdge(1, 3, 1);
         graph.insertEdge(1, 4, 1);
         graph.insertEdge(3, 7, 1);
         graph.insertEdge(4, 7, 1);
         graph.insertEdge(2, 5, 1);
         graph.insertEdge(2, 6, 1);
         graph.insertEdge(5, 6, 1);

        //显示一把邻结矩阵
        graph.showGraph();
        //测试一把，我们的 dfs 遍历是否 ok
//        System.out.println("深度遍历");
//        graph.dfs(); // A->B->C->D->E [1->2->4->8->5->3->6->7]
        // System.out.println();
        System.out.println("广度优先!");
        graph.bfs(); // A->B->C->D-E [1->2->3->4->5->6->7->8]
    }
    // 构造器
    public Graph(int n){
        // 初始化矩阵和vertexList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
    }


    //插入节点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    /***
     *
     * @param v1 表示点的下标即第几个顶点 “A”-“B” “A”->0 "B"->1
     * @param v2
     * @param weight
     */
    public void insertEdge(int v1, int v2, int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }
    // 显示图对应的矩阵
    public void showGraph(){
        for (int[] link : edges) {
            System.out.println(Arrays.toString(link));
        }
    }
    //i 第一次就是 0
    private void dfs(boolean[] isVisited, int i){
        // 首先我们访问该节点输出
        System.out.print(getValueByIndex(i) + "->");
        // 将节点设置为已访问
        isVisited[i] = true;
        // 查找节点i的第一个邻接节点w
        int w = getFirstNeighbor(i);
        while (w != -1){
            // 说明找到了下一个邻接节点
            if (!isVisited[w]){
                // 如果下一个邻接节点没被访问过， 那么就用这个节点继续递归
                dfs(isVisited, w);
            }
            // 如果w节点已经被访问过。 就继续往下找节点
            w = getNextNeighbor(i, w);
        }
    }
    // 对dfs进行一个重载，遍历我们所有的节点， 并进行dfs
    public void dfs(){
        isVisited = new boolean[vertexList.size()];
        for (int i = 0; i <getNumOfVertex(); i++) {
            if (!isVisited[i]){
                dfs(isVisited, i);
            }
        }
    }
    public int getNumOfVertex(){
        return vertexList.size();
    }
    // 根据前一个邻接节点的下标来获取下一个临街节点
    private int getFirstNeighbor(int index){
        for (int i = 0; i < vertexList.size(); i++) {
            if (edges[index][i] >0){
                return i;
            }
        }
        return -1;
    }

    // 根据前一个邻接节点的下标来获取下一个邻接节点
    public int getNextNeighbor(int v1, int v2){
        for (int i = v2 + 1; i < vertexList.size(); i++) {
            if (edges[v1][i] > 0){
                return i;
            }
        }
        return -1;
    }

    private String getValueByIndex(int i){
        return vertexList.get(i);
    }
   // 对一个节点进行广度优先遍历的方法
    public void bfs(boolean[] isVisited, int i){
        int u; // 表示队列的头结点对应下标
        int w; // 邻接节点w
        // 队列。记录结点访问的顺序
        LinkedList<Integer> queue = new LinkedList<Integer>();
        // 访问节点 输出结点信息
        System.out.print(getValueByIndex(i) + "=>");
        // 标记已访问
        isVisited[i] = true;
        // 将结点加入队列
        queue.addLast(i);
        while (!queue.isEmpty()){
            // 取出队列的头结点下标
            u = queue.removeFirst();
            // 得到第一个邻接节点的下标w
            w = getFirstNeighbor(u);
            while (w != -1){
                // 找到
                // 是否访问过
                if (!isVisited[w]){
                    System.out.print(getValueByIndex(w) + "=>");
                    // 标记已经访问
                    isVisited[w] = true;
                    //  入队
                    queue.addLast(w);
                }
                // 以u为前驱节点，找w后面的下一个邻接节点
                w = getNextNeighbor(u, w); // 体现出广度
            }
        }
    }
    //遍历所有的结点，都进行广度优先搜索
    public void bfs(){
        isVisited = new boolean[vertexList.size()];
        for (int i = 0; i <getNumOfVertex(); i++) {
            if (!isVisited[i]){
                bfs(isVisited, i);
            }
        }
    }
}

```

### 图的深度优先 VS 广度优先

![image-20220321204051418](images\image-20220321204051418.png)

# 十三、程序员常用 10 种算法

## 1、二分查找算法(非递归)

二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找，二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 < 100 < 2^7)

```java
public class BinarySearchNoRecur {

    public static void main(String[] args) {
        //测试
        int[] arr = {1,3, 8, 10, 11, 67, 100};
        int index = binarySearch(arr, 100);
        System.out.println("index=" + index);//

        int i = binarySearchRecur(arr, 11, 0, arr.length - 1);
        System.out.println("index=" + i);
    }

    public static int binarySearch(int[] arr, int target){
        int left = 0;
        int right = arr.length - 1;
        while (left <= right){
            int mid = (left + right)/2;
            if (arr[mid] == target){
                return mid;
            }else if (target > arr[mid]){
                left = mid +1;
            }else {
                right = mid-1;
            }
        }
        return -1;
    }
    public static int binarySearchRecur(int[] arr, int target, int left, int right){
        if (left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        if (target > arr[mid]){
            return binarySearchRecur(arr,target, mid+1, right);
        }else if (target < arr[mid]){
            return binarySearchRecur(arr, target,left,mid-1);
        }else {
            return mid;
        }
    }
}


```

## 2、分治算法

### 分治算法介绍

治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或
相似的子问题，再把子问题分成更小的子问题......直到最后子问题可以简单的直接求解，原问题的解即子问题
的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变
换)......

分治算法可以求解的一些经典问题
    二分搜索
    大整数乘法
    棋盘覆盖
    合并排序
    快速排序
    线性时间选择
    最接近点对问题
    循环赛日程表
    汉诺塔

### 分治算法的基本步骤

分治法在每一层递归上都有三个步骤：
1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题

2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

3) 合并：将各个子问题的解合并为原问题的解

分治(Divide-and-Conquer(P))算法设计模式如下

![image-20220321211945774](images\image-20220321211945774.png)

### 分治算法最佳实践-汉诺塔

汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金
刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小
顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

汉诺塔游戏的演示和思路分析

1) 如果是有一个盘， A->C
	如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘
2) 先把 最上面的盘 A->B
3) 把最下边的盘 A->C
4) 把 B 塔的所有盘 从 B->C

```java
package com.harry.algorithm.dac;

public class Hanoitower {
    public static void main(String[] args) {
        hanoiTower(64, 'A', 'B', 'C');
    }

    // 汉诺塔的移动方法
    // 使用分治算法
    public static void hanoiTower(int num, char a, char b, char c){
        // 如果只有一个盘
        if (num == 1){
            System.out.println("第 1 个盘从 " + a + "->" + c);
        }else {
            // 如果我们有 n>2 情况， 我们总是可以看做是两个盘 1.最下边的一个盘 2 上面的所有盘
            // 1. 先把最上面的所有盘 A->B 移动过程会用到C
            hanoiTower(num-1, a, c, b);
            // 2. 把最下边的盘A->C
            System.out.println("第" + num + "个盘从 " + a + "->" + c);
            // 3. 把B塔的所有盘从B->C 移动过程中用到a塔
            hanoiTower(num-1, b,a,c);
        }
    }
}

```

## 3、动态规划算法

### 应用场景-背包问题

背包问题：有一个背包，容量为 4 磅 ， 现有如下物品

![image-20220321213150589](images\image-20220321213150589.png)

1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出
2) 要求装入的物品不能重复

### 动态规划算法介绍

1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这
些子问题的解得到原问题的解。

3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ）

4) 动态规划可以通过填表的方式来逐步推进，得到最优解



背包问题：有一个背包，容量为 4 磅 ， 现有如下物

![image-20220321213409565](images\image-20220321213409565.png)

1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出
2) 要求装入的物品不能重复

思路分析和图解

3) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用)

4) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。

5) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品
放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v\[i][j]表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：

> 1) v\[i][0]=v\[0][j]=0; //表示 填入表 第一行和第一列是 0
> (2) 当 w[i]> j 时：v\[i][j]=v\[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个
> 单元格的装入策略
> (3) 当 j>=w[i]时： v\[i][j]=max{v\[i-1][j], v[i]+v\[i-1][j-w[i]]}
> // 当 准备加入的新增的商品的容量小于等于当前背包的容量,
> // 装入的方式:
> v\[i-1][j]： 就是上一个单元格的装入的最大值
> v[i] : 表示当前商品的价值
> v\[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值
> 当 j>=w[i]时： v\[i][j]=max{v\[i-1][j], v[i]+v\[i-1][j-w[i]]} 

6) 图解的分析

![image-20220321213905705](images\image-20220321213905705.png)

```java
package com.harry.algorithm.dynamic;

public class KnapsackProblem {
    public static void main(String[] args) {
        int[] w = {1, 4, 3}; // 物品的重量
        int[] val = {1500, 3000, 2000}; // 物品的价值 这里val[i] 就是前面讲的v[i]
        int m = 4; // 背包的容量
        int n = val.length; // 物品的个数

        // 创建二维数组
        // v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
        int[][]v = new int[n+1][m+1]; // 加1是因为 第一行第一列要设置成0
        // 为了记录放入商品的情况，我们定义一个二维数组
        int[][]path = new int[n+1][m+1];

        //初始化第一行和第一列，这里在本程序中可以不去处理，因为默认就是0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0; //将第一列设置为0
        }
        for (int i = 0; i <v[0].length ; i++) {
            v[0][i] = 0; // 将第一行设置0
        }
        // 根据前面得到公式来动态规划处理
        for (int i = 1; i <v.length ; i++) {
            // 不处理第一行i是从1开始的
            for (int j = 1; j <v[0].length ; j++) {
                // 不处理第一列，j从1开始的
                // 公式
                if (w[i-1] > j){
                    // 因为我们程序i是从1开始的，因此原来公式中的w[i]修改成w[i-1]
                    v[i][j] = v[i-1][j];
                }else {
                    // 因为我们的i从1开始的，因此公式需要调整成 v[i][j]=Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]);
                    // 第一次 v[1][1] = max(0,1500)
                    // 为了记录商品存放到背包的情况，我们不能直接使用上面的公式，需要使用if-else来体现公式
                    if (v[i-1][j] < val[i-1]+v[i-1][j-w[i-1]]){
                        v[i][j] = val[i-1]+v[i-1][j-w[i-1]];
                        // 把当前的情况记录到path
                        path[i][j] = 1;
                    }else {
                        v[i][j] = v[i-1][j];
                    }

                }

            }
        }
        // 输出一下v看看目前的情况
        for (int i = 0; i <v.length ; i++) {
            for (int j = 0; j <v[i].length ; j++) {
                System.out.print(v[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println("============================");
        //输出最后我们是放入的哪些商品
        //遍历 path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入

        int row = path.length - 1; // 行的最大下标
        int col = path[0].length - 1;// 列的最大下标

        while (row >0 && col >0){// 从path的最后开始找
            if (path[row][col] == 1){
                System.out.printf("第%d 个商品放入到背包\n", row);
                col -=w[row-1];
            }
            row--;
        }
    }
}

```

## 4、KMP算法

### 应用场景-字符串匹配问题

字符串匹配问题：
	1) 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅
你"
	2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1

### 暴力匹配算法

如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有：

​	1) 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符

​	2) 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。

​	3) 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)

​	4) 暴力匹配算法实现.

​	5) 代码

```java
package com.harry.algorithm.kmp;

public class ViolenceMatch {
    public static void main(String[] args) {
        //测试暴力匹配算法
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int index = violenceMatch(str1, str2);
        System.out.println("index=" + index);
    }
    // 暴力匹配算法实现
    public static int violenceMatch(String str1, String str2){
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int s1Len = s1.length;
        int s2Len = s2.length;

        int i = 0; // i索引指向s1
        int j = 0; // j索引指向s2
        while (i <s1Len && j < s2Len){
            if (s1[i] == s2[j]){
                // 匹配ok
                i++;
                j++;
            }else{
                //如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。
                i = i -(j-1);
                j = 0;
            }

        }
        // 判断是否匹配成功
        if (j == s2Len){
            return i - j;
        }else {
            return -1;
        }
    }
}

```

### KMP 算法介绍

​	1) KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法

​	2) Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的
姓氏命名此算法.

​	3) KMP 方法算法就利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间

​	4) 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html

### KMP 算法最佳应用-字符串匹配问题

字符串匹配问题：：
	1) 有一个字符串 str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串 str2="ABCDABD"
	2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1
	3) 要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法.

思路分析图解

举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 =
“ABCDABD”？
  1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位

![image-20220323211259587](images\image-20220323211259587.png)

2. 重复第一步，还是不符合，再后移

![image-20220323211330868](images\image-20220323211330868.png)

3. 一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止

![image-20220323211355409](images\image-20220323211355409.png)

4. 接着比较字符串和搜索词的下一个字符，还是符合。

![image-20220323211433221](images\image-20220323211433221.png)

 5.遇到 Str1 有一个字符与 Str2 对应的字符不符合

![image-20220323211512108](images\image-20220323211512108.png)

6.这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。
KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这
样就提高了效率。)

![image-20220323211558835](images\image-20220323211558835.png)

7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍

![image-20220323211650126](images\image-20220323211650126.png)

8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分
匹配值”为 2，因此按照下面的公式算出向后移动的位数：
移动位数 = 已匹配的字符数 - 对应的部分匹配值
因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。

9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”
为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。

![image-20220323211808132](images\image-20220323211808132.png)

10.因为空格与 A 不匹配，继续后移一位。

![image-20220323215712705](images\image-20220323215712705.png)

11.逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位

![image-20220323215742256](images\image-20220323215742256.png)

12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），
移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。

![image-20220323215812626](images\image-20220323215812626.png)

13.介绍《部分匹配表》怎么产生的
先介绍前缀，后缀是什么

![image-20220323215858671](images\image-20220323215858671.png)

“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，
－”A”的前缀和后缀都为空集，共有元素的长度为 0；
－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0；
－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0；
－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0；
－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1；
－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为 2；
－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD,D]，共有元素的长度为 0。

```java
package com.harry.algorithm.kmp;

import jdk.nashorn.internal.ir.IfNode;

import java.util.Arrays;

public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int[] next = kmpNext("ABCDABD"); //[0, 1, 2, 0]
        System.out.println("next=" + Arrays.toString(next));
        int index = kmpSearch(str1, str2, next);
        System.out.println("index=" + index); // 15 了
    }


    //写出我们的 kmp 搜索算法
    /**
     *
     * @param str1 源字符串
     * @param str2 子串
     * @param next 部分匹配表, 是子串对应的部分匹配表
     * @return 如果是-1 就是没有匹配到，否则返回第一个匹配的位置
     */
    public static int kmpSearch(String str1, String str2, int[] next) {

        // 遍历
        for (int i = 0,j=0; i <str1.length() ; i++) {
            // 需要处理str.charAt(i) != str2.charAt(j) , 去调整j的大小
            // KMP算法核心点可以验证
            while (j>0 && str1.charAt(i) != str2.charAt(j)){
                j = next[j-1];
            }

            if (str1.charAt(i) == str2.charAt(j)){
                j++;
            }

            if (j == str2.length()){
                // 找到了  j = 3 i
                return i-j+1;
            }

        }
        return  -1;
    }

    // 获取找到一个字符串(子串)
    public static int[] kmpNext(String dest){
        // 创建一个next数组保存部分匹配
        int[] next = new int[dest.length()];
        next[0] = 0; // 如果字符串是长度为1 部分匹配值就是0
        for (int i = 1, j=0; i < dest.length()  ; i++) {
            // 当dest.charAt(i) != dest.charAt(j) , 我们需要从next[j-1]重新获取新的j
            // 直到我们发现有 dest.charAt(i) == dest.charAt(j)成立才退出
            // 这是kmp算法的核心点
            while (j>0 && dest.charAt(i) != dest.charAt(j)){
                j = next[j-1];
            }
            // 当dest.charAt(i) == dest.charAt(j)满足时，部分匹配值就是+1
            if (dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}

```

## 5、贪心算法

### 应用场景-集合覆盖问题

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区
都可以接收到信号

![image-20220326103519429](images\image-20220326103519429.png)

### 贪心算法介绍

1) 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而
希望能够导致结果是最好或者最优的算法

2) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果

### 贪心算法最佳应用-集合覆盖

1) 假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有
的地区都可以接收到信号

![image-20220326103727810](images\image-20220326103727810.png)

2) 思路分析:
	如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假
	设总的有 n 个广播台，则广播台的组合总共有

2ⁿ -1 个,假设每秒可以计算 10 个子集， 如图:

![image-20220326103825556](images\image-20220326103825556.png)

用贪婪算法，效率高:
	1) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择
策略上，因为需要覆盖全部地区的最小集合:

​	2) 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关
系）

​	3) 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。

​	4) 重复第 1 步直到覆盖了全部的地区

![image-20220326104206601](images\image-20220326104206601.png)

```java
package com.harry.algorithm.greedy;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm {
    public static void main(String[] args) {
        // 创建广播电台，放入到Map
        HashMap<String, HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
        //将各个电台放入到 broadcasts

        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        //加入到 map
        broadcasts.put("K1", hashSet1);
        broadcasts.put("K2", hashSet2);
        broadcasts.put("K3", hashSet3);
        broadcasts.put("K4", hashSet4);
        broadcasts.put("K5", hashSet5);
        //allAreas 存放所有的地区
        HashSet<String> allAreas = new HashSet<String>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");

        //创建 ArrayList, 存放选择的电台集合
        ArrayList<String> selects = new ArrayList<String>();

        //定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<String>();

        // 定义maxKey, 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
        // 如果maxKey不为null 则会加入到selects
        String maxKey = null;
        while (allAreas.size() != 0){
            // 每进入一次while需要
            maxKey = null;
            int maxTemp = 0;
            for (String key : broadcasts.keySet()) {
                // 每进行一次 for, 清理一下temp
                tempSet.clear();
                // 当前这个key能够覆盖的地区
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                // 求出tempSet和allAreas集合的交集。交集会赋给tempSet
                tempSet.retainAll(allAreas);
                // 如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多 就需要重置maxKey
                // tempSet.size() >broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的
                if (tempSet.size() > 0 && (maxKey == null || tempSet.size() > maxTemp)){
                    maxKey = key;
                    maxTemp = tempSet.size();
                }
            }
            // maxKey != null 就应该将maxKey加入selects
            if (maxKey != null){
                selects.add(maxKey);
                // 将maxKey指向的广播电台覆盖的地区从allAreas去掉
                allAreas.removeAll(broadcasts.get(maxKey));
            }

        }
        System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]
    }
}

```

### 贪心算法注意事项和细节

1) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果
2) 比如上题的算法选出的是 K1, K2, K3, K5，符合覆盖了全部的地区
3) 但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果 K2 的使用成本低于 K1,那么我们上题的 K1, K2, K3,
K5 虽然是满足条件，但是并不是最优的.



## 6、普里姆算法

看一个应用场景和问题

![image-20220327095436055](images\image-20220327095436055.png)

1) 有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通
2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里
3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?

思路: 将 10 条边，连接即可，但是总的里程数不是最小.
正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少

### 最小生成树

修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称 MST。
给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树

1) N 个顶点，一定有 N-1 条边

2) 包含全部顶点

3) N-1 条边都在图中

4) 举例说明(如图:)

5) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法

![image-20220327095642289](images\image-20220327095642289.png)

### 普里姆算法介绍

普利姆(Prim)算法求最小生成树，也就是在包含 n 个顶点的连通图中，找出只有(n-1)条边包含所有 n 个顶点的
连通子图，也就是所谓的极小连通子图
普利姆的算法如下：

​	1) 设 G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合

​	2) 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 visited[u]=1

​	3) 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合 U 中，将边（ui,vj）加入集合 D 中，标记 visited[vj]=1

​	4) 重复步骤②，直到 U 与 V 相等，即所有顶点都被标记为访问过，此时 D 中有 n-1 条边

​	5) 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.

​	6) 图解普利姆算法

![image-20220327095942884](images\image-20220327095942884.png)

### 普里姆算法最佳实践(修路问题)

![image-20220327100042436](images\image-20220327100042436.png)

1) 有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通

2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里

3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?



```java
package com.harry.algorithm.prim;

import java.util.Arrays;

public class PrimAlgorithm {
    public static void main(String[] args) {
        // 测试看看图是否创建 ok
        char[] data = new char[]{'A','B','C','D','E','F','G'};
        int verxs = data.length;
        //邻接矩阵的关系使用二维数组表示,10000 这个大数，表示两个点不联通
        int [][]weight=new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000},};
        //创建 MGraph 对象
        MGraph graph = new MGraph(verxs);
        //创建一个 MinTree 对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph, verxs, data, weight);
        //输出
        minTree.showGraph(graph);
        //测试普利姆算法
        minTree.prim(graph, 1);//
    }

}

// 创建最小生成树->村庄
class MinTree{
    //创建图的邻接矩阵
    /**
     *
     * @param graph 图对象
     * @param verxs 图对应的顶点个数
     * @param data 图的各个顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) {
        int i,j;
        for ( i = 0; i < verxs; i++) {
            // 顶点
            graph.data[i] = data[i];
            for (j=0; j<verxs; j++){
                graph.weight[i][j] = weight[i][j];
            }
        }
     }

     // 显示图的邻接矩阵
    public void showGraph(MGraph graph){
        for(int[] link: graph.weight) {
            System.out.println(Arrays.toString(link));
        }
    }

    //编写 prim 算法，得到最小生成树
    /**
     *
     * @param graph 图
     * @param v 表示从图的第几个顶点开始生成'A'->0 'B'->1...
     */
     public void prim(MGraph graph, int v){
         // visited[]标记节点（顶点）是否被访问过
         int visited[] = new int[graph.verxs];
         // visited[] 默认元素的值都是0 表示没有访问过
         // java里面初始化就是0
         // for(int i =0; i <graph.verxs; i++) {
         // visited[i] = 0;
         // }

         // 把当前这个节点标记为已访问
         visited[v] = 1;
         // h1和h2记录两个顶点的下标
         int h1 = -1;
         int h2 = -1;
         int minWeight = 10000; // 将minWeight 初始成一个大数 后面在遍历过冲中会被替换
         for (int k = 1; k <graph.verxs ; k++) {
            // 因为有graph.verxs顶点，普利姆算法结束后，有graph.verxs-1边
             //这个是确定每一次生成的子图，和哪个节点的距离最近

             for (int i = 0; i <graph.verxs ; i++) { // i节点表示被访问过的节点
                 for (int j = 0; j <graph.verxs ; j++) {
                     if (visited[i] == 1 && visited[j] == 0 && graph.weight[i][j] < minWeight){
                         // 替换minWeight(寻找已经访问过的节点和未访问过的节点间的权值最小的边)
                         minWeight = graph.weight[i][j];
                         h1 = i;
                         h2 = j;
                     }
                 }

             }
             //找到一条边是最小
             System.out.println("边<" + graph.data[h1] + "," + graph.data[h2] + "> 权值:" + minWeight);
             // 将当前这个节点标记为已经访问
             visited[h2] = 1;
             // minWeight 重新设置为最大值10000
             minWeight = 10000;
         }
     }
}

class MGraph{
    int verxs; // 表示图的节点个数
    char[] data; // 存放节点数据
    int[][] weight; // 存放边，就是我们的邻接矩阵
    public MGraph(int verxs){
        this.verxs = verxs;
        data = new char[verxs];
        weight = new int[verxs][verxs];
    }
}
```

## 7、克鲁斯卡尔算法

### 应用场景-公交站问题

![image-20220328195935177](images\image-20220328195935177.png)

1) 某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通
2) 各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里
3) 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?

### 克鲁斯卡尔算法介绍

1) 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。
2) 基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路
3) 具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森
林中不产生回路，直至森林变成一棵树为止

### 鲁斯卡尔算法图解说明

以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤：

在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到
最小，则称其为连通网的最小生成树。

![image-20220328200249713](images\image-20220328200249713.png)

例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树。

![image-20220328200315467](images\image-20220328200315467.png)

### 克 鲁 斯 卡 尔 算 法 图 解

以上图 G4 为例，来对克鲁斯卡尔进行演示(假设，用数组 R 保存最小生成树结果)。

![image-20220328200438038](images\image-20220328200438038.png)

![image-20220328200503174](images\image-20220328200503174.png)

> 第 1 步：将边<E,F>加入 R 中。
> 边<E,F>的权值最小，因此将它加入到最小生成树结果 R 中。
>
> 第 2 步：将边<C,D>加入 R 中。
> 上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果 R 中。
>
> 第 3 步：将边<D,E>加入 R 中。
> 上一步操作之后，边<D,E>的权值最小，因此将它加入到最小生成树结果 R 中。
>
> 第 4 步：将边<B,F>加入 R 中。
> 上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳过边<C,F>。将边<B,F>加入到最小生成树结果 R 中。
>
> 第 5 步：将边<E,G>加入 R 中。
> 上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果 R 中。
>
> 第 6 步：将边<A,B>加入 R 中。
> 上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳过边<B,C>。将边<A,B>加入到最小生成树结果 R 中。
>
> 此时，最小生成树构造完成！它包括的边依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。

### 克 鲁 斯 卡 尔 算 法 分 析

根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问
题：
	问题一 对图的所有边按照权值大小进行排序。
	问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。

问题一很好解决，采用排序算法进行排序即可。
问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"。
然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。

### 如 何 判 断 是 否 构 成 回 路 - 举 例 说 明 ( 如 图 ）

![image-20220328200914803](images\image-20220328200914803.png)

在将<E,F> <C,D> <D,E>加入到最小生成树 R 中之后，这几条边的顶点就都有了终点：
	(01) C 的终点是 F。
	(02) D 的终点是 F。
	(03) E 的终点是 F。
	(04) F 的终点是 F。

关于终点的说明：
	1) 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。
	2) 因此，接下来，虽然<C,E>是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】

### 克鲁斯卡尔最佳实践-公交站问题

1) 有北京有新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通
2) 各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里
3) 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?
4) 代码实现和注解

```java
package com.harry.algorithm.kruskal;

import java.util.Arrays;

public class KruskalCase {
    private int edgeNum; // 边的个数
    private char[] vertexs; // 顶点数组
    private int[][] matrix; // 邻接矩阵
    // 使用INF表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        char[] vertexs = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        //克鲁斯卡尔算法的邻接矩阵
        int matrix[][] = {
              /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
        /*A*/ { 0, 12, INF, INF, INF, 16, 14},
        /*B*/ { 12, 0, 10, INF, INF, 7, INF},
        /*C*/ { INF, 10, 0, 3, 5, 6, INF},
        /*D*/ { INF, INF, 3, 0, 4, INF, INF},
        /*E*/ { INF, INF, 5, 4, 0, 2, 8},
        /*F*/ { 16, 7, 6, INF, 2, 0, 9},
        /*G*/ { 14, INF, INF, INF, 8, 9, 0}};
            //大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.

        //创建 KruskalCase 对象实例
        KruskalCase kruskalCase = new KruskalCase(vertexs, matrix);
        //输出构建的
        kruskalCase.print();
        kruskalCase.kruskal();
    }

    // 构造器
    public KruskalCase(char[] vertexs, int[][] matrix){
        // 初始化顶点数和边的个数
        int vlen = vertexs.length;
        // 初始化顶点，复制拷贝的方式
        this.vertexs = new char[vlen];
        for (int i = 0; i < vertexs.length ; i++) {
            this.vertexs[i] = vertexs[i];
        }
        // 初始化边，使用的是复制拷贝的方法
        this.matrix = new int[vlen][vlen];
        for (int i = 0; i <vlen ; i++) {
            for (int j = 0; j <vlen ; j++) {
                this.matrix[i][j] = matrix[i][j];
            }
        }
        // 统计边的条数
        for (int i = 0; i < vlen; i++) {
            for (int j = i+1; j <vlen ; j++) {
                if (this.matrix[i][j] != INF){
                    edgeNum++;
                }
            }
        }


    }

    public void kruskal(){
        int index = 0; // 表示最后结果数组的索引
        int[] ends = new int[edgeNum]; // 用于保存“已有最小生成树”中的每个顶点在最小生成树中的终点
        // 创建结果数组，保存最后的最小生成树
        EData[] rets = new EData[edgeNum];
        // 获取图中所有的边的集合， 一共有12条边
        EData[] edges = getEdges();
        System.out.println("图的边的集合=" + Arrays.toString(edges) + " 共"+ edges.length); //12

        // 按照边的权值大小进行排序(从小到大）
        sortEdges(edges);
        // 遍历edges数组，将边添加到最小生成树中时，判断是准备加入的边是否形成了回路，如果没有就加入rets, 否则不能加入
        for (int i = 0; i <edgeNum ; i++) {
            // 获取到第i条边的第一个顶点(起点)
            int p1 = getPosition(edges[i].start); // p1=4
            // 获取到第i条边的第2个顶点
            int p2 = getPosition(edges[i].end);
            // 获取p1这个顶点在已有最小生成树的终点
            int m = getEnd(ends, p1);
            //获取 p2 这个顶点在已有最小生成树中的终点
            int n = getEnd(ends, p2);
            if (m != n){
                // 没有构成回路
                ends[m] = n; // 设置m在“已有最小生成树”中的终点<E,F> [0,0,0,0,5,0,0,0,0,0,0,0]
                rets[index++] = edges[i]; // 有一条边加入到rets数组
            }
            //<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
            //统计并打印 "最小生成树", 输出 rets

        }
        System.out.println("最小生成树为");
        for(int i = 0; i < index; i++) {
            System.out.println(rets[i]);
        }

    }

    /***
     * 功能: 获取下标为 i 的顶点的终点(), 用于后面判断两个顶点的终点是否相同
     * @param ends: 数组就是记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中逐步形成
     * @param i： 表示传入的顶点对应的下标
     * @return 返回的就是下标为i的这个顶点对应的终点的下标。
     */
    private int getEnd(int[] ends, int i){// i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]
        while (ends[i] != 0){
            i = ends[i];
        }
        return i;
    }

    // 打印邻接矩阵
    public void print(){
        System.out.println("邻接矩阵为: \n");
        for(int i = 0; i < vertexs.length; i++) {
            for(int j=0; j < vertexs.length; j++) {
                System.out.printf("%12d", matrix[i][j]);
            }
            System.out.println();//换行
        }
    }

    /**
     * 功能：对边进行排序处理
     * @param edges
     */
    private void sortEdges(EData[] edges){
        for (int i = 1; i <edges.length ; i++) {
            int insertValue = edges[i].weight;
            int insertIndex = i-1;
            while (insertIndex >= 0 && insertValue < edges[insertIndex].weight){
                edges[insertIndex+1].weight = edges[insertIndex].weight;
                insertIndex--;
            }
            edges[insertIndex+1].weight = insertValue;
        }
    }

    /**
     *
     * @param ch 顶点的值， 比如“A”,"B"
     * @return 返回ch顶点对应的下标， 如果找不到就返回-1
     */
    private int getPosition(char ch){
        for (int i = 0; i < vertexs.length; i++) {
            if (vertexs[i] == ch){
                // 找到
                return i;
            }
        }
        return -1;
    }

    /**
     * 功能：获取图中边放到EData[]数组中，后面我们需要遍历该数组
     * 是通过matrix邻接矩阵来获取
     * EData[] 形式 [['A','B', 12], ['B','F',7], .....]
     * @return
     */
    private EData[] getEdges(){
        int index = 0;
        EData[] edges = new EData[edgeNum];
        for (int i = 0; i <vertexs.length ; i++) {
            for (int j = i+1; j <vertexs.length ; j++) {
                if (matrix[i][j] != INF){
                    edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]);
                }
            }
        }
        return edges;
    }
}


// 创建一个类EData它的对象实例就表示一条边
class  EData{
    char start; // 边的一个点
    char end; // 边的另外一个点
    int weight; // 边的权值
    public EData(char start, char end , int weight){
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    //重写 toString, 便于输出边信息
    @Override
    public String toString() {
        return "EData [<" + start + ", " + end + ">= " + weight + "]";
    }
}
```

## 8、 迪杰斯特拉算法

### 应用场景-最短路径问题

![image-20220330192517383](D:\studyDoc\javaimages\image-20220330192517383.png)

1) 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到
A, B, C , D, E, F 六个村庄

2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里

3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离?

4) 如果从其它点出发到各个点的最短距离又是多少?

### 迪杰斯特拉(Dijkstra)算法介绍

迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以
起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。

### 迪杰斯特拉(Dijkstra)算法过程

1) 设置出发顶点为 v，顶点集合 V{v1,v2,vi...}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di...}，Dis
集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di)

2) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径

3) 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的)

4) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

![image-20220330192913292](images\image-20220330192913292.png)

```java
package com.harry.algorithm.dijkstra;

import java.util.Arrays;

public class DijkstraAlgorithm {
    public static void main(String[] args) {
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        //邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;// 表示不可以连接
        matrix[0]=new int[]{N,5,7,N,N,N,2};
        matrix[1]=new int[]{5,N,N,9,N,N,3};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,3,N,N,4,6,N};
        //创建 Graph 对象
        Graph graph = new Graph(vertex, matrix);
        //测试, 看看图的邻接矩阵是否 ok
        graph.showGraph();
        //测试迪杰斯特拉算法
        graph.dsj(6);//C
        graph.showDijkstra();
    }
}

class Graph{
    private char[] vertex; // 顶点数组
    private int[][] matrix; // 邻接矩阵
    private VisitedVertex vv; // 已经访问的顶点的集合

    public Graph(char[] vertex, int[][] matrix){
        this.vertex = vertex;
        this.matrix = matrix;
    }
    // 显示结果
    public void showDijkstra(){
        vv.show();
    }
    // 显示图
    public void showGraph(){
        for (int[] link : matrix) {
            System.out.println(Arrays.toString(link));
        }
    }
    //迪杰斯特拉算法实现
    /**
     *
     * @param index 表示出发顶点对应的下标
     */
    public void dsj(int index) {
        vv = new VisitedVertex(vertex.length, index);
        update(index); // 更新index顶点到周围顶点的距离和前驱顶点
        for (int j = 1; j < vertex.length; j++) {
            index = vv.updateArr(); // 选择并返回新的访问顶点
            update(index); // 更新index顶点到周围顶点的距离和前驱顶点
        }
    }

    // 更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点
    public void update(int index){
        int len = 0;
        // 根据遍历我们的邻接矩阵的matrix[index]行
        for (int j = 0; j < matrix[index].length; j++) {
            // len含义是：出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和
            len = vv.getDis(index) + matrix[index][j];
            // 如果j顶点没有被访问过，并且len小于出发顶点到j顶点的距离，就需要更新
            if (!vv.in(j) && len < vv.getDis(j)){
                vv.updatePre(j, index); // 更新j顶点的前驱为index顶点
                vv.updateDis(j, len); // 更新出发顶点到j顶点的距离
            }

        }
    }

}

// 已访问顶点集合
class VisitedVertex{
    // 记录各个顶点是否访问过1表示访问过， 0未访问，会动态更新
    public int[] already_arr;
    // 每个下标对应的值为前一个顶点下标，会动态更新
    public int[] pre_visited;
    // 记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录G到其他顶点的距离，会动态更新，求得最短距离就会存放到dis
    public int[] dis;

    //构造器
    /**
     *
     * @param length :表示顶点的个数
     * @param index: 出发顶点对应的下标, 比如 G 顶点，下标就是 6
     */
    public VisitedVertex(int length, int index) {
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];

        // 初始化dis数组
        Arrays.fill(dis, 65535);
        this.already_arr[index] = 1; // 设置出发顶点被访问过
        this.dis[index] = 0; // 设置出发顶点的访问距离为0
    }

    /**
     * 功能： 判断index顶点是否被访问过
     * @return 如果访问过，就返回 true, 否则访问 false
     */
    public boolean in(int index){
        return already_arr[index] == 1;
    }

    /**
     * 功能: 更新出发顶点到 index 顶点的距离
     * @param index
     * @param len
     */
    public void updateDis(int index, int len){
        dis[index] = len;
    }

    /**
     * 功能: 更新 pre 这个顶点的前驱顶点为 index 顶点
     * @param pre
     * @param index
     */
    public void updatePre(int pre, int index){
        pre_visited[pre] = index;
    }

    /**
     * 功能:返回出发顶点到 index 顶点的距离
     * @param index
     */
    public int getDis(int index){
        return dis[index];
    }
    /**
     * 继续选择并返回新的访问顶点， 比如这里的 G 完后，就是 A 点作为新的访问顶点(注意不是出发顶点)
     * @return
     */
    public int updateArr(){
        int min=65535,index = 0;
        for (int i = 0; i <already_arr.length ; i++) {
            if (already_arr[i] == 0 && dis[i] < min){
                min = dis[i];
                index = i;
            }
        }
        // 更新index顶点被访问过
        already_arr[index] = 1;
        return index;
    }
    //显示最后的结果
    //即将三个数组的情况输出
    public void show() {
        System.out.println("==========================");
        //输出 already_arr
        for(int i : already_arr) {
            System.out.print(i + " ");
        }
        System.out.println();
        //输出 pre_visited
        for(int i : pre_visited) {
            System.out.print(i + " ");
        }
        System.out.println();
        //输出 dis
        for(int i : dis) {
            System.out.print(i + " ");
        }
        System.out.println();
        //为了好看最后的最短距离，我们处理
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        int count = 0;
        for (int i : dis) {
            if (i != 65535){
                System.out.println(vertex[count] + "("+i+") ");
            }else {
                System.out.println("N ");
            }
            count++;
        }
        System.out.println();
    }
}
```

