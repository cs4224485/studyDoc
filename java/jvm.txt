一 JVM简介
	JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

	Java语言的一个非常重要的特点就是与平台的无关性。
	而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。
	而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。

X JVM的声明周期
	1. 虚拟机的启动
		java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的, 这个类是由虚拟机的具体实现指定的。
	
	2. 虚拟机的执行
		一个运行中的java虚拟机有着一个清晰的任务：执行java程序
		程序开始执行时他才运行，程序结束时他就停止
		执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做JAVA虚拟机的程序
		
	3. JAVA虚拟机退出
		如下几种情况虚拟机会退出
			* 程序正常执行结束
			* 程序在执行过程中遇到了异常或错误而异常终止
			* 由于操作系统出现错误而导致Java虚拟机进程终止
			* 某线程调用Runtime类或System类的exit方法,或Runtime类的halt方法, 并且Java安全管理器也允许这次exit或halt操作
			* 除此之外，JNI规范描述了JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况
	
类装载器
	负责加载class文件，class文件在文件开头有特定的文件表示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定
	
	* 虚拟机自带的加载器
	* 启动类加载器(Bootstrap) C++
	* 扩展类加载器(Extension) JAVA
	* 应用程序类加载器(AppClassLoader)Java也叫系统类加载器, 加载当前应用的classpath的所有类
	* 用户自定义加载器 java.lang.ClassLoader的子类， 用户可以定制类的加载方式
	
	类加载器的双亲委派：
		当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
		只有当父类加载器反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需加载的Class),子类加载器才会尝试自己去加载
		
		采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object, 不管是哪个加载器加载这个类, 最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。
	
	Native Interface本地接口
		本地接口的作用是融合不同的编程语言为Java所用， 它的初衷是融合C/C++程序，java诞生的时候是C/C++横行的时候，必须调用C/C++程序, 于是就在内存中专门开辟了一块区域处理标记native的代码

PC寄存器
	
	每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储指向下一条指令的地址, 也即将要执行的指令代码), 由执行引擎读取下一条指令，上一个非常小的内存空间，几乎可以忽略不记。
	这块内存区域很小，它是当前线程所执行的字节码的信号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。
	如果执行的是一个Native方法,那这个计数器是空的
	用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误
	
	
Methdod Area方法区 
	供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容。
	上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代和元空间
	But，实例变量存在堆内存中和方法区无关。

栈
	栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。
	8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。

	栈存什么
		栈帧中主要保存3类数据:
			本地变量(Local Variables)： 输入参数和输出参数以及方法内的变量
			帧操作(Operand Stack):	记录出栈、入栈操作；
			栈帧数据(Frame Data)：包括类文件、方法等等
		
	栈运行原理：
		栈中的数据都是以栈帧(Stack Fram)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，
		当一个方法A被调用时就产生了一个栈帧F1,并被压入到栈中,
		A方法有调用了B方法，于是产生栈帧F2也被压入栈
		B方法有调用C方法，于是产生栈帧F3也被压入栈
		执行完毕后，先弹出F3栈帧，再弹出F2栈帧， 再弹出F1栈....
		遵循"先进后出"/"后进先出"原则
		
		每个方法执行的同时都会创建一栈帧，用于存储局部变量表、操作数栈、动态链表、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。
		栈的大小和具体JVM实现有关，通常在256K~756K之间，与等于1MB左右。
	
	
Heap 堆
	
	一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分:
	Young Generation Space   新生区			Young/New
	Tenure generation Space  养老区			Old/Tenure
	Permanet Space			 永久区			Perm
	
	新生区静态版：
		新生区是类的诞生、成长、消亡的区域，一个类再这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分:伊甸区(Eden space)和幸存者区(Survivor space), 所有的类都是在伊甸区被new出来的。
		幸存者区有两个:0区(Survivor 0 space)和1区(Survivor 1 space)。 当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将堆伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园去进行垃圾回收(Minor GC),将伊甸园去中移动到幸存0区，
		若幸存0区也满了，再对该去进行垃圾回收，然后移动到1区。如果1区也满了，再移动到养老区。 若养老区也满了，那么这个时候将产生MajorGC(FullGC)， 进行养老区的内存管理。
		若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常"OutOfMemoryError"
		
		如果出现java.lang.OutOfMemoryError:java heap space 异常，说明java虚拟机的内存不够。原因有二：
			(1) java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。
			(2) 代码中构建了大量大对象，并且长时间不能被垃圾回收器收集
	
	MinorGC的过程(复制->清空->互换)
		1： eden、SurivivorFrom复制到SurivivorTo， 年龄+1
			首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SuriviorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域，对这两个区域进行垃圾回收。
			经过这次回收后还存活的对象，则直接复制到To区域(如果有对象的年龄已经达到了老年的标准，则赋值到老年代区)
		2: 清空eden、SurvivorFrom
			然后清空Eden和SurvivoFrom中的对象，也即复制之后有交换，谁空谁是To
		
		3：SurvivorTo和SurvivoFrom互换
			最后，SurivivorTo和SurvivoFrom互换， 原SurvivorTo称为下一次GC时的SurivivorFrom区。部分对象会在From和To区域中复制来复制去，如此交换15次(由JVM参赛MaxTenuringThreshold决定，这个参数默认15)，最终如果还存活，就存入老年代
	
	永久代(java7)元空间(java8)
		实际而言，方法区(Methdo Area)和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的:类信息+普通常量+静态常量+编译器编译后的代码。
		虽然JVM规范将方法区描述为堆的一个逻辑部分，单它却还有一个别名Non-Heap(非堆内存)，目的就是要和堆分开。
		
		对于HotSpot虚拟机，很多开发者习惯将方法区称之为"永久代"，单严格本质上说两者不同，或者说使用永久代实现方法区而已，永久代是方法区(想打昂与是一个接口interface)的一个实现。
		JDK1.的版本中，已经将原本放在永久代的字符串常量池移走
	

JVM调参
	
	在JAVA8中，永久代已经被移除，被一个称为元空间的区域所取代。
	元空间的本质和永久代类似。
	
	元空间与永久代之间最大的区别在于：
		永久代使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存
	
	因此,默认情况下,元空间的大小仅受本地内存限制。类的元数据放入native memory, 字符串池和类的静态变量放入java堆中，这样可以加载多少类的元数据就不在由MaxPermSize控制，而由系统的实际可用空间来控制。
	
	-Xms  					设置初始分配大小，默认为物理内存的"1/64"
	-Xmx  					最大分配内存，默认为物理内存的"1/4"
	-XX:PrintGCDetails		输出详细的GC处理器
	
	-Xms1024m -Xmx1024m -XX:+PrintGCDetails
	
	public class JVMParam {
		public static void main(String[] args) {
			long maxMemory = Runtime.getRuntime().maxMemory(); // 返回Java虚拟机视图使用的最大内存量
			long totalMemory = Runtime.getRuntime().totalMemory(); // 返回Java虚拟机中的内存总量。
			System.out.println("-Xmx:MAX_MEMORY=" + maxMemory +"(字节)、"+(maxMemory/(double)1024/1024) + "MB");
			System.out.println("-Xms:TOTAL_MEMORY="+ totalMemory+ "(字节)、"+(totalMemory/(double)1024/1024) + "MB");

		}
	}
	
	
	JVM在进行GC时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是新生代
	因此GC安装回收的区域又分了两种类型， 一种是普通GC(minor GC)， 一种是全局GC(major GC OR Full GC)
	
	Minor GC和Full GC的区别
		
		普通GC(minor GC):只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率不高，所以Minor GC非常频繁， 一般回收速度比较快
		全局GC(major GC or Full GC): 指发生在老年代的垃圾收集动作，出现了Major GC, 经常会伴随至少一次的Minor GC(但并不是绝对的)。MajorGC速度一般要比MinorGC慢上10倍

GC四大算法
	1. 引用计数法
		一个对象，每有一个应用时计数就会+1，如果引用为0时就会被回收
		缺点：每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗
			  较难处理循环引用
			  
	2. 复制算法
		年轻代中使用的是Minor GC， 这种GC算法采用的是复制算法
		Minor GC 会把Eden中的所有活的对象都移动到Survivor区域中， 如果Survivror区中放不下，那么剩下的活的对象就被移动到Old generation中，也即一旦收集后，Eden是就变成空的了。
		当对象在Eden(包括一个Survivor区域，这里假设是from区域)出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另外一块Survivor区域所容纳(上面已经假设为from区域，这里应为to区域，即to区域有足够的内存空间来存储Eden和grom区域存活的对象)，
		则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域(即to区域)中，然后清理所使用过的Eden以及Survivor区域(即from区域), 并且将这些对象年龄设置为1，以后对象在Survivor区每熬过一次Minor GC，就将对象的年龄+1，当对象的年龄达到某个值时(默认15)这些对象就会成为老年代
	
		-XX:MaxTenuringThreshold -- 设置对象在新生代中存活的次数
		
		复制算法流程：
			HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区(分别叫from和to)。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会移动到Survivor区。
			对象在Survivor区中每熬过一次MinorGC， 年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。
			因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当一块内存用完，就将还活着的对象复制到另外一块上面。 复制算法不会产生内存碎片。
		
		复制算法它的缺点也是相当明显的
			1 它浪费了一半的内存空间
			2 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。 复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视
			
			所有从以上描述可以看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存浪费
		
	3. 标记清除法
		
		老年代一般是由标记清除或者标记清除与标记整理的混合
		用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。
		优点：节约内存空间
		缺点：两次扫描耗时严重， 会产生内存碎片
	
	4. 标记压缩法
		与标记-清除一样，多了一个压缩的步骤，会再次扫描并向一端滑动存活对象
		优点：没有内存碎片，可以利用bump
		缺点: 需要移动对象的成本 耗时长
	
JMM(JAVA内存模型 Java Memory Model，简称JMM)
	JMM本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。
	
	JMM关于同步的规定
		1 线程解锁前，必须把共享变量的值刷新回主内存
		2 线程加锁前，必须读取主内存的最新值到自己的工作内存
		3 加锁解锁是同一把锁
	
	由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问
	但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作内存中的变量，
	各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。
 